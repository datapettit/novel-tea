<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Novel Studio – OpenAI HTML Client</title>
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script id="google-gsi-script" src="https://accounts.google.com/gsi/client" async defer></script>
  <script id="google-gapi-script" src="https://apis.google.com/js/api.js" async defer></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #0b0c10;
      color: #e5e5e5;
      font-family: "Fira Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    #app {
      display: flex;
      height: 100vh;
      padding-bottom: 180px; /* keep controls visible when console is expanded */
      box-sizing: border-box;
    }
    #sidebar {
      width: 320px;
      border-right: 1px solid #1f2833;
      background: #0b0c10;
      padding: 10px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 8px;
      overflow-y: auto;
    }
    #main {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    #loading-indicator {
      position: fixed;
      top: 12px;
      right: 12px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border: 1px solid #45a29e;
      background: rgba(11, 12, 16, 0.9);
      border-radius: 6px;
      z-index: 30;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
    }
    #loading-indicator.visible {
      display: flex;
    }
    .loading-spinner {
      width: 18px;
      height: 18px;
      border: 3px solid #1f2833;
      border-top-color: #66fcf1;
      border-radius: 50%;
      animation: spin 0.9s linear infinite;
    }
    .loading-text {
      font-size: 12px;
      color: #c5c6c7;
    }
    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
    .section-title {
      font-weight: bold;
      margin-top: 10px;
      margin-bottom: 4px;
      color: #66fcf1;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    input, select, button, textarea {
      font-family: inherit;
      font-size: 13px;
    }
    input[type=text], input[type=password] {
      width: 100%;
      box-sizing: border-box;
      padding: 4px 6px;
      border-radius: 3px;
      border: 1px solid #1f2833;
      background: #0b0c10;
      color: #e5e5e5;
    }
    button {
      background: #45a29e;
      border: none;
      color: #0b0c10;
      padding: 4px 8px;
      border-radius: 3px;
      cursor: pointer;
      margin-top: 4px;
    }
    button:hover {
      background: #66fcf1;
    }
    button.small {
      font-size: 11px;
      padding: 2px 6px;
      margin-left: 4px;
    }
    #controls {
      padding: 8px;
      border-top: 1px solid #1f2833;
      background: #0b0c10;
      box-sizing: border-box;
      font-size: 13px;
    }
    #character-canvas {
      display: none;
      flex: 1;
      flex-direction: column;
      background: #0b0c10;
      border-bottom: 1px solid #1f2833;
      padding: 10px;
      box-sizing: border-box;
      overflow: hidden;
      gap: 8px;
    }
    #doc-canvas {
      display: none;
      flex: 1;
      flex-direction: column;
      background: #0b0c10;
      border-bottom: 1px solid #1f2833;
      padding: 10px;
      box-sizing: border-box;
      gap: 10px;
      overflow: hidden;
    }
    #canvas-gallery {
      display: flex;
      align-items: center;
      gap: 8px;
      background: #0d1117;
      border: 1px solid #1f2833;
      border-radius: 4px;
      padding: 6px;
      min-height: 86px;
      box-sizing: border-box;
    }
    #canvas-gallery-window {
      flex: 1;
      overflow: hidden;
    }
    #canvas-gallery-track {
      display: flex;
      gap: 8px;
      transition: scroll-behavior 0.3s ease;
      overflow-x: auto;
      scrollbar-width: thin;
      width: max-content;
    }
    .canvas-thumb {
      width: 110px;
      height: 70px;
      border: 1px solid #1f2833;
      border-radius: 4px;
      overflow: hidden;
      position: relative;
      background: #11161f;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #c5c6c7;
      font-size: 11px;
      text-align: center;
    }
    .canvas-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    .canvas-thumb .thumb-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 2px 4px;
      background: rgba(0, 0, 0, 0.65);
      font-size: 10px;
      color: #66fcf1;
      box-sizing: border-box;
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
    }
    .gallery-nav {
      background: #1f2833;
      color: #c5c6c7;
      border: 1px solid #45a29e;
      border-radius: 4px;
      width: 26px;
      height: 60px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
    }
    .gallery-nav:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .canvas-gallery-empty {
      color: #7b848f;
      padding: 12px;
      font-size: 12px;
    }
    #character-canvas.visible {
      display: flex;
    }
    #canvas-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
    }
    #canvas-header .title {
      font-weight: bold;
      font-size: 14px;
      color: #66fcf1;
    }
    #canvas-document {
      width: 100%;
      min-height: 220px;
      border: 1px solid #1f2833;
      border-radius: 4px;
      padding: 10px;
      background: #0b0c10;
      color: #e5e5e5;
      box-sizing: border-box;
      white-space: pre-wrap;
      line-height: 1.5;
      outline: none;
      overflow-y: auto;
    }
    #canvas-chat-log {
      flex: 1;
      border: 1px solid #1f2833;
      border-radius: 4px;
      padding: 8px;
      overflow-y: auto;
      background: #0d1117;
      box-sizing: border-box;
    }
    .canvas-msg {
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid #1f2833;
      white-space: pre-wrap;
    }
    .canvas-msg .role {
      font-weight: bold;
      color: #45a29e;
    }
    #canvas-input-row {
      display: flex;
      gap: 8px;
      align-items: flex-start;
    }
    #canvas-user-prompt {
      flex: 1;
      min-height: 60px;
      resize: vertical;
      border: 1px solid #1f2833;
      border-radius: 4px;
      padding: 6px;
      background: #0b0c10;
      color: #e5e5e5;
    }
    #canvas-controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    #canvas-controls-row label {
      font-size: 12px;
      color: #c5c6c7;
    }
    #canvas-upload-input {
      display: none;
    }
    #doc-canvas.visible {
      display: flex;
    }
    #story-canvas {
      display: none;
      flex: 1;
      flex-direction: column;
      background: #0b0c10;
      border-bottom: 1px solid #1f2833;
      padding: 10px;
      box-sizing: border-box;
      gap: 10px;
      overflow: hidden;
    }
    #story-canvas.visible {
      display: flex;
    }
    .modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }
    .modal-box {
      background: #0b0c10;
      border: 1px solid #1f2833;
      border-radius: 6px;
      padding: 12px;
      min-width: 260px;
      color: #e5e5e5;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
    }
    #image-viewer {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.86);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 40;
    }
    #image-viewer.visible {
      display: flex;
    }
    #image-viewer .viewer-frame {
      position: relative;
      background: #0d1117;
      border: 1px solid #1f2833;
      border-radius: 10px;
      padding: 12px;
      max-width: 90vw;
      max-height: 90vh;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
    }
    #image-viewer img {
      max-width: 80vw;
      max-height: 80vh;
      display: block;
      border-radius: 8px;
    }
    #image-viewer .viewer-close {
      position: absolute;
      top: 8px;
      right: 8px;
      background: #1f2833;
      color: #e5e5e5;
      border: 1px solid #45a29e;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      cursor: pointer;
    }
    .mode-toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: #0d1117;
      border: 1px solid #1f2833;
      padding: 4px 6px;
      border-radius: 6px;
    }
    .mode-toggle button {
      margin-top: 0;
      padding: 4px 8px;
      font-size: 12px;
      background: #1f2833;
      color: #c5c6c7;
      border: 1px solid #1f2833;
    }
    .mode-toggle button.active {
      background: #45a29e;
      color: #0b0c10;
      border-color: #66fcf1;
    }
    .modal-box h4 {
      margin: 0 0 8px 0;
      color: #66fcf1;
      font-size: 14px;
    }
    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 10px;
    }
    #project-list {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #1f2833;
      padding: 4px;
      border-radius: 3px;
      font-size: 12px;
    }
    .project-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 2px 0;
    }
    .project-name {
      cursor: pointer;
      color: #c5c6c7;
    }
    .project-name:hover {
      color: #66fcf1;
      text-decoration: underline;
    }
    .project-actions button {
      background: #1f2833;
      color: #c5c6c7;
      font-size: 10px;
      padding: 2px 4px;
      margin-left: 3px;
    }
    .project-actions button:hover {
      background: #45a29e;
      color: #0b0c10;
    }
    .divider {
      height: 1px;
      background: #1f2833;
      margin: 8px 0;
    }
    #status-bar {
      font-size: 11px;
      color: #c5c6c7;
      margin-top: 4px;
    }
    #controls-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 4px;
    }
    .control-group {
      border: 1px solid #1f2833;
      border-radius: 4px;
      padding: 6px;
      min-width: 220px;
      max-width: 360px;
    }
    .control-group-title {
      font-weight: bold;
      margin-bottom: 4px;
      color: #66fcf1;
      font-size: 12px;
    }
    .menu-panel {
      border: 1px solid #1f2833;
      border-radius: 6px;
      overflow: hidden;
      background: #0d1117;
    }
    .menu-panel summary {
      cursor: pointer;
      padding: 8px 10px;
      font-weight: bold;
      color: #66fcf1;
      background: #0f111a;
      border-bottom: 1px solid #1f2833;
      list-style: none;
      transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .menu-panel.active summary {
      background: linear-gradient(90deg, rgba(102, 252, 241, 0.14), transparent);
      border-left: 3px solid #66fcf1;
      box-shadow: inset 0 0 0 1px rgba(102, 252, 241, 0.25);
    }
    .menu-body {
      padding: 8px 10px 12px 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .menu-subgroup {
      border: 1px solid #1f2833;
      border-radius: 4px;
      padding: 8px;
      background: #0b0c10;
    }
    .menu-subtitle {
      font-weight: bold;
      color: #c5c6c7;
      margin-bottom: 6px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    .roster-list {
      border: 1px solid #1f2833;
      border-radius: 4px;
      max-height: 140px;
      overflow-y: auto;
      padding: 6px;
      background: #0d1117;
      font-size: 12px;
      color: #c5c6c7;
    }
    .roster-row {
      padding: 4px 0;
      border-bottom: 1px solid #151a24;
    }
    .roster-row:last-child {
      border-bottom: none;
    }
    .menu-inline-controls {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
    }
    .control-group button {
      display: block;
      width: 100%;
      margin-top: 4px;
      text-align: left;
      font-size: 12px;
    }
    a.download-link {
      color: #66fcf1;
      text-decoration: underline;
      cursor: pointer;
    }
    #file-upload-input {
      margin-top: 4px;
    }
    #console-panel {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      background: #0b0c10;
      border-top: 1px solid #1f2833;
      box-shadow: 0 -2px 6px rgba(0, 0, 0, 0.4);
      font-size: 12px;
      z-index: 70;
    }
    #console-panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 10px;
      cursor: pointer;
      background: #11161f;
      color: #c5c6c7;
      border-bottom: 1px solid #1f2833;
    }
    #console-toggle-btn {
      background: #1f2833;
      color: #c5c6c7;
      border: 1px solid #45a29e;
      border-radius: 3px;
      padding: 2px 6px;
      font-size: 11px;
      cursor: pointer;
    }
    #console-panel-body {
      display: none;
      max-height: 220px;
      overflow-y: auto;
      padding: 8px 10px;
    }
    #console-panel.expanded #console-panel-body {
      display: block;
    }
    #console-log .line {
      margin: 2px 0;
    }
    #console-log .line .prefix {
      color: #45a29e;
    }
    #console-log .line.error {
      color: #ff6b6b;
    }
    .character-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 10px;
      margin-top: 8px;
    }
    .character-card {
      border: 1px solid #1f2833;
      border-radius: 6px;
      background: linear-gradient(135deg, #0f111a, #151c29);
      height: 130px;
      position: relative;
      cursor: pointer;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #c5c6c7;
      transition: border-color 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
    }
    .character-card:hover {
      border-color: #45a29e;
      transform: translateY(-2px);
    }
    .character-card.selected {
      border-color: #66fcf1;
      box-shadow: 0 0 0 2px rgba(102, 252, 241, 0.35);
    }
    .character-card.selected::after {
      content: "";
      position: absolute;
      inset: 2px;
      border: 1px solid rgba(102, 252, 241, 0.5);
      border-radius: 5px;
      pointer-events: none;
      box-shadow: 0 0 12px rgba(102, 252, 241, 0.3);
    }
    .character-card .card-image {
      position: absolute;
      inset: 0;
      background-size: 100% auto;
      background-position: center;
      opacity: 0.4;
      filter: saturate(1.1);
      transition: opacity 0.2s ease;
    }
    .character-card:hover .card-image {
      opacity: 0.75;
    }
    .character-card.selected .card-image {
      opacity: 1;
    }
    .character-card .card-overlay {
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.55));
    }
    .character-card .card-name {
      position: relative;
      text-align: center;
      font-weight: bold;
      z-index: 2;
      padding: 0 6px;
    }
    .character-card .card-add-icon {
      font-size: 36px;
      line-height: 1;
      color: #66fcf1;
      z-index: 2;
    }
    .character-card.new-card {
      border-style: dashed;
      border-color: #45a29e;
      background: #0d1117;
      color: #66fcf1;
    }
    .character-card.new-card:hover {
      border-color: #66fcf1;
      background: #101724;
    }
    .character-grid-empty {
      grid-column: 1 / -1;
      text-align: center;
      color: #7b848f;
      font-size: 12px;
      padding: 10px 0;
    }
    .character-grid-hint {
      font-size: 11px;
      color: #c5c6c7;
      margin-top: 6px;
    }
    .doc-list {
      border: 1px solid #1f2833;
      border-radius: 6px;
      background: #0d1117;
      overflow-y: auto;
      max-height: 380px;
      font-size: 12px;
    }
    .doc-row {
      display: grid;
      grid-template-columns: 2fr 1fr 0.7fr 120px;
      gap: 8px;
      align-items: center;
      padding: 8px 10px;
      border-bottom: 1px solid #151a24;
    }
    .doc-row:last-child {
      border-bottom: none;
    }
    .doc-row-header {
      font-weight: bold;
      color: #c5c6c7;
      background: #101724;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .doc-row .doc-actions {
      display: flex;
      justify-content: flex-end;
      gap: 6px;
    }
    .doc-row button {
      margin-top: 0;
      padding: 4px 8px;
      font-size: 12px;
    }
    .icon-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      font-size: 12px;
      min-width: 34px;
    }
    #doc-preview {
      border: 1px solid #1f2833;
      border-radius: 6px;
      background: #0d1117;
      padding: 10px;
      min-height: 160px;
      overflow: auto;
      font-size: 12px;
      line-height: 1.5;
    }
    #doc-preview img {
      max-width: 100%;
      height: auto;
      display: block;
    }
    #doc-canvas-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 8px;
    }
    #doc-canvas-header .title {
      font-weight: bold;
      font-size: 14px;
      color: #66fcf1;
    }
    #doc-canvas-actions {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    #story-canvas-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    #story-canvas-header .title {
      font-size: 14px;
      font-weight: bold;
      color: #66fcf1;
    }
    #story-canvas-actions {
      display: flex;
      gap: 6px;
      align-items: center;
      flex-wrap: wrap;
    }
    .modal-error {
      color: #ff6b6b;
      font-size: 11px;
      margin-top: 6px;
    }
    #auth-overlay {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at center, rgba(11, 12, 16, 0.96), rgba(11, 12, 16, 0.98));
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
    }
    #auth-card {
      width: min(520px, 90%);
      background: #0d1117;
      border: 1px solid #1f2833;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
      color: #e5e5e5;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    #auth-card h2 {
      margin: 0;
      font-size: 20px;
      color: #66fcf1;
    }
    #auth-card p {
      margin: 0;
      color: #c5c6c7;
      line-height: 1.4;
      font-size: 14px;
    }
    #google-auth-btn {
      align-self: flex-start;
      background: #4285f4;
      color: #fff;
      padding: 8px 12px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
    }
    #google-auth-btn:hover {
      background: #5a95f5;
    }
    #auth-status-text {
      font-size: 12px;
      color: #c5c6c7;
    }

    #project-picker-overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.78);
      z-index: 50;
    }

    #project-picker-overlay.visible {
      display: flex;
    }

    #project-picker-card {
      background: #0d1117;
      border: 1px solid #1f2833;
      border-radius: 8px;
      padding: 16px;
      width: min(520px, 92vw);
      color: #e5e5e5;
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.6);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    #project-picker-card h3 {
      margin: 0;
      color: #66fcf1;
    }

    #project-picker-list {
      max-height: 240px;
      overflow-y: auto;
      border: 1px solid #1f2833;
      border-radius: 6px;
      padding: 8px;
      background: #0b0c10;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .project-picker-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      border-radius: 4px;
      border: 1px solid #1f2833;
      background: #0f141c;
    }

    .project-picker-row.selected {
      border-color: #45a29e;
      background: #111a22;
    }

    .project-picker-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    #project-picker-status {
      font-size: 12px;
      color: #c5c6c7;
    }
    #app.locked {
      filter: blur(1px);
      pointer-events: none;
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="auth-overlay">
    <div id="auth-card">
      <h2>Connect Google Drive</h2>
      <p>
        Novel Studio now uses your Google Drive as the source of truth for all images and documents.
        Sign in to grant Drive access before working with any projects.
      </p>
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
      <button id="google-auth-btn">Sign in with Google Drive</button>
      <button id="google-reload-btn" class="small" style="background:#1f2833;color:#e5e5e5;">Force reload SDK</button>
    </div>
    <div id="auth-status-text">Waiting for sign-in...</div>
  </div>
</div>
<div id="project-picker-overlay">
  <div id="project-picker-card">
    <h3>Select a Drive project</h3>
    <p style="margin:0;color:#c5c6c7;">
      Choose a Google Drive folder whose name starts with "novel - ". Only these folders can be used as project roots.
    </p>
    <div id="project-picker-status">Loading Drive projects...</div>
    <div id="project-picker-list"></div>
    <div class="project-picker-actions">
      <input type="text" id="picker-new-project-input" placeholder="New project name (without 'novel -')" />
      <button id="picker-create-project-btn">Create & Use</button>
    </div>
    <div class="project-picker-actions" style="justify-content: space-between;">
      <div style="display:flex;gap:6px;align-items:center;">
        <button id="picker-refresh-btn" class="small">Refresh list</button>
        <button id="picker-use-selected-btn">Use Selected</button>
      </div>
      <button id="picker-cancel-btn" class="small" style="background:#444;color:#e5e5e5;">Exit picker</button>
    </div>
  </div>
</div>
<div id="loading-indicator">
  <div class="loading-spinner"></div>
  <div class="loading-text">Working...</div>
</div>
<div id="app" class="locked">
  <div id="sidebar">
    <div class="section-title">API Key</div>
    <input type="password" id="api-key-input" placeholder="Enter OpenAI API key" />
    <button id="set-api-key-btn">Set API Key</button>
    <div id="api-key-status" style="font-size:11px;color:#c5c6c7;margin-top:4px;">
      Not set
    </div>

    <div class="section-title" style="margin-top:10px;">Assistant Model</div>
    <select id="model-select">
      <option value="gpt-4.1">gpt-4.1 (latest default)</option>
      <option value="gpt-4o">gpt-4o</option>
      <option value="gpt-4o-mini">gpt-4o-mini</option>
    </select>
    <div id="model-status" style="font-size:11px;color:#c5c6c7;margin-top:4px;">
      Using: gpt-4.1 (latest default)
    </div>

    <div class="divider"></div>

    <div class="section-title">Projects (novel - ...)</div>
    <div id="project-list"></div>

    <input type="text" id="new-project-name" placeholder="New project name (without 'novel -')" style="margin-top:6px;" />
    <button id="create-project-btn">Create Project</button>
    <button id="open-project-picker-btn" class="small">Choose Drive Project</button>
    <button id="delete-project-btn" style="background:#ff6b6b;color:#0b0c10;margin-top:4px;">Delete Selected</button>
    <button id="exit-drive-project-btn" style="background:#444;color:#e5e5e5;margin-top:4px;">Exit Drive Project</button>

    <div id="current-project-label" style="margin-top:10px;font-size:12px;color:#c5c6c7;">
      Current project: <span id="current-project-name">None</span>
    </div>

    <div class="section-title" style="margin-top:14px;">Workspace Menus</div>

    <details class="menu-panel" id="setup-docs-panel">
      <summary>Setup & Docs</summary>
      <div class="menu-body">
        <div class="menu-subgroup">
          <div class="menu-subtitle">Assistant Setup</div>
          <button id="init-assistants-btn">Initialize / Recreate Assistants</button>
        </div>
        <div class="menu-subgroup">
          <div class="menu-subtitle">Document Libraries</div>
          <div style="margin-top:2px;font-size:11px;">Upload documents to vector stores:</div>
          <select id="doc-category-select">
            <option value="characters">characters</option>
            <option value="locations">locations</option>
            <option value="relationships">relationships</option>
            <option value="storyline">storyline</option>
            <option value="history">history</option>
            <option value="outlines">outlines</option>
            <option value="drafts">drafts</option>
          </select>
          <input type="file" id="file-upload-input" multiple />
          <div class="menu-inline-controls">
            <button id="upload-docs-btn">Upload Docs for Category</button>
            <button id="list-category-files-btn">List Files in Category</button>
          </div>
          <select id="category-file-select" style="width:100%;">
            <option value="">(refresh to see files)</option>
          </select>
          <div class="menu-inline-controls">
            <button id="refresh-category-files-btn">Refresh File List</button>
            <button id="remove-category-file-btn">Remove File from Category</button>
          </div>
        </div>
      </div>
    </details>

    <details class="menu-panel" id="character-panel">
      <summary>Character Development</summary>
      <div class="menu-body">
        <div class="menu-subgroup">
          <div class="menu-subtitle">Roster</div>
          <button id="refresh-characters-btn">Refresh Character Roster</button>
          <div id="character-grid" class="character-grid"></div>
          <div class="character-grid-hint">Click a profile to open its canvas. Use the + card to add a new character.</div>
          <div style="margin-top:6px;font-size:11px;">Current: <span id="current-character-name">None</span></div>
        </div>
        <div class="menu-subgroup">
          <div class="menu-subtitle">Sheets & Canvas</div>
          <button id="work-character-sheet-btn" style="margin-top:0;">Open Character Canvas</button>
          <button id="scan-characters-btn">Scan for Other Characters</button>
        </div>
        <div class="menu-subgroup">
          <div class="menu-subtitle">Photos</div>
          <div style="margin-top:2px;font-size:11px;">Photo (jpeg/png):</div>
          <input type="file" id="character-photo-input" accept="image/jpeg,image/png" />
          <div class="menu-inline-controls">
            <select id="photo-action-select" style="min-width:160px;">
              <option value="profile-upload">Replace Profile (upload)</option>
              <option value="profile-drive">Replace Profile (Drive)</option>
              <option value="profile-edit-draft">Draft from Existing Profile</option>
              <option value="promote-draft">Promote Draft</option>
              <option value="gallery-draft">Generate Draft Gallery Image</option>
            </select>
            <select id="photo-target-select" style="min-width:180px;">
              <option value="">(choose existing)</option>
            </select>
          </div>
          <button id="character-photo-btn">Handle Character Photos</button>
        </div>
      </div>
    </details>

    <details class="menu-panel">
      <summary>Story Building</summary>
      <div class="menu-body">
        <div class="menu-subgroup">
          <div class="menu-subtitle">Story Targets</div>
          <div class="menu-inline-controls">
            <select id="book-select" style="min-width:120px;">
              <option value="">Select book</option>
            </select>
            <button id="refresh-story-targets-btn" class="small">Refresh</button>
          </div>
          <div class="menu-inline-controls">
            <select id="act-select" style="min-width:90px;">
              <option value="">Act</option>
            </select>
            <select id="chapter-select" style="min-width:110px;">
              <option value="">Chapter</option>
            </select>
          </div>
        </div>
        <div class="menu-subgroup">
          <div class="menu-subtitle">Outlines</div>
          <button id="build-trilogy-outline-btn">Build Trilogy Outline (Text)</button>
          <button id="build-book-outline-btn">Build Book Outline (JSON)</button>
        </div>
        <div class="menu-subgroup">
          <div class="menu-subtitle">Story Arc Canvas</div>
          <button id="open-story-canvas-btn">Open Story Arc Canvas</button>
        </div>
        <div class="menu-subgroup">
          <div class="menu-subtitle">Chapters</div>
          <button id="draft-chapter-btn">Draft a Chapter From JSON Outline</button>
          <button id="draft-whole-book1-btn">Draft Entire Book 1 Automatically</button>
          <button id="edit-chapter-btn">Review / Edit a Chapter</button>
        </div>
        <div class="menu-subgroup">
          <div class="menu-subtitle">Review & Audio</div>
          <button id="review-book-btn">Book-Level Consistency Review</button>
          <button id="tts-chapter-btn">Generate TTS for a Chapter</button>
        </div>
        <div class="menu-subgroup">
          <div class="menu-subtitle">Sora / Video</div>
          <button id="sora-stub-btn" style="margin-top:0;">(Stub) Sora / Video Generation</button>
        </div>
      </div>
    </details>
  </div>

  <div id="main">
    <div id="doc-canvas">
      <div id="doc-canvas-header">
        <div class="title">Document Explorer: <span id="doc-canvas-category">characters</span></div>
        <div id="doc-canvas-actions">
          <button id="doc-add-btn">Add document(s)</button>
          <button id="doc-refresh-btn">Refresh List</button>
          <button id="doc-resync-btn">Resync to Vector Store</button>
          <button id="doc-drafts-toggle" class="small">Show Drafts</button>
        </div>
      </div>
      <div class="doc-list" id="doc-list"></div>
      <div id="doc-preview">Select a document to preview its contents here.</div>
      <input type="file" id="doc-canvas-upload" multiple style="display:none;" />
    </div>
    <div id="story-canvas">
      <div id="story-canvas-header">
        <div class="title">Story Arc Canvas</div>
        <div class="mode-toggle" id="story-mode-toggle">
          <button data-mode="edit" class="active">Edit Arc</button>
          <button data-mode="qa">Ask Questions</button>
        </div>
        <div id="story-canvas-actions">
          <button id="story-save-btn">Save Story Arc</button>
          <button id="story-refresh-btn" class="small">Reload</button>
        </div>
      </div>
      <div
        id="story-canvas-document"
        contenteditable="true"
        aria-label="Story arc canvas"
        style="flex:1;overflow:auto;border:1px solid #1f2833;padding:8px;border-radius:4px;background:#0d1117;"
      ></div>
      <div id="story-chat-log"></div>
      <div id="story-input-row">
        <input type="text" id="story-user-prompt" placeholder="Enter an edit request or a question" />
        <button id="story-send-btn">Send to Assistant</button>
      </div>
    </div>
    <div id="character-canvas">
      <div id="canvas-gallery">
        <button id="canvas-gallery-prev" class="gallery-nav">&#8249;</button>
        <div id="canvas-gallery-window">
          <div id="canvas-gallery-track"></div>
        </div>
        <button id="canvas-gallery-next" class="gallery-nav">&#8250;</button>
      </div>
      <div id="canvas-header">
        <div class="title">Character Canvas: <span id="canvas-character-name">None</span></div>
        <div class="mode-toggle" id="character-mode-toggle">
          <button data-mode="edit" class="active">Edit Sheet</button>
          <button data-mode="chat">Discuss Character</button>
        </div>
        <div id="canvas-controls-row">
          <label for="canvas-ext-select">Format:</label>
          <select id="canvas-ext-select">
            <option value="txt">txt</option>
            <option value="docx">docx</option>
          </select>
          <button id="save-character-sheet-btn">Save Sheet</button>
          <button id="download-character-docx-btn">Download Word Doc</button>
          <button id="upload-character-docx-btn">Upload Word Doc</button>
          <input type="file" id="canvas-upload-input" accept=".docx,application/vnd.openxmlformats-officedocument.wordprocessingml.document" />
        </div>
      </div>
      <div
        id="canvas-document"
        contenteditable="true"
        aria-label="Character sheet canvas"
      ></div>
      <div id="canvas-chat-log"></div>
      <div id="canvas-input-row">
        <textarea id="canvas-user-prompt" placeholder="Ask the assistant to adjust this sheet..."></textarea>
        <button id="canvas-send-btn">Send</button>
      </div>
    </div>
    <div id="controls">
      <div class="section-title" style="margin-top:0;">Status</div>
      <div id="status-bar">Ready.</div>
    </div>
  </div>
</div>

<div id="image-viewer">
  <div class="viewer-frame">
    <button class="viewer-close" id="image-viewer-close">×</button>
    <img id="image-viewer-img" alt="Image preview" />
    <div id="image-viewer-caption" style="margin-top:8px;font-size:12px;color:#c5c6c7;"></div>
  </div>
</div>

<div id="console-panel" class="collapsed">
  <div id="console-panel-header">
    <span id="console-panel-title">Console (collapsed)</span>
    <button id="console-toggle-btn">Expand</button>
  </div>
  <div id="console-panel-body">
    <div id="console-log"></div>
  </div>
</div>

<script>

  // ==============================
  // GLOBAL STATE
  // ==============================

  const DEFAULT_API_KEY = "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";
  let apiKey = DEFAULT_API_KEY;
  const PROJECTS_KEY = "novelStudioProjects"; // localStorage key
  const MODEL_KEY = "novelStudioAssistantModel";
  const ASSISTANT_MODELS = ["gpt-4.1", "gpt-4o", "gpt-4o-mini"];
  const GOOGLE_CLIENT_ID =
    new URLSearchParams(window.location.search).get("googleClientId") ||
    "YOUR_GOOGLE_CLIENT_ID";
  const GOOGLE_SCOPES = [
    "https://www.googleapis.com/auth/drive",
    "https://www.googleapis.com/auth/drive.file",
    "https://www.googleapis.com/auth/drive.metadata",
  ].join(" ");
  const PROJECT_PREFIX = "novel - ";
  const CATEGORY_FOLDERS = [
    "characters",
    "locations",
    "relationships",
    "storyline",
    "history",
    "outlines",
    "drafts",
  ];
  const CHARACTER_CATEGORY = "characters";
  let googleTokenClient = null;
  let googleAccessToken = null;
  let googleAuthorized = false;
  let googleDriveReady = false;
  let googleInitPromise = null;
  let googleSdkLoadPromise = null;
  let googleUserEmail = null;

  function resetGoogleSdkState() {
    googleDriveReady = false;
    googleInitPromise = null;
    googleSdkLoadPromise = null;
    googleTokenClient = null;
    ["google-gsi-script", "google-gapi-script"].forEach((id) => {
      const existing = document.getElementById(id);
      if (existing) existing.remove();
    });
    logLine("Google SDK state cleared. Reloading scripts is now allowed.");
  }
  let projects = {}; // { projectName: {name, assistants, vectorStores, outlines, chapters} }
  let currentProjectName = null;
  let assistantModel = ASSISTANT_MODELS[0];
  let currentCharacterName = null;
  let storyConversationMode = "edit";
  let currentStoryArc = null;
  let consoleExpanded = false;
  let docEditorState = null;
  let characterConversationMode = "edit";
  let docExplorerShowDrafts = false;
  const imageCache = new Map();
  let suppressMenuToggle = false;
  let projectPickerResolver = null;
  let projectPickerSelection = null;

  const isFileOrigin = window.location.protocol === "file:";
  const isLocalhostOrigin = ["localhost", "127.0.0.1", "[::1]"].includes(window.location.hostname);
  let loggedLocalhostHint = false;

  function fileToDataUrl(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }

  function dataUrlToFile(dataUrl, filename) {
    const arr = dataUrl.split(",");
    const mimeMatch = arr[0].match(/:(.*?);/);
    const mime = mimeMatch ? mimeMatch[1] : "application/octet-stream";
    const bstr = atob(arr[1]);
    let n = bstr.length;
    const u8arr = new Uint8Array(n);
    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }
    return new File([u8arr], filename, { type: mime });
  }

  async function ensureDataUrlFromFileId(fileId, filename = "image.png") {
    if (!fileId) return { dataUrl: null, blob: null, filename };
    if (imageCache.has(fileId)) {
      const cached = imageCache.get(fileId);
      return { dataUrl: cached.dataUrl, blob: cached.blob };
    }
    const content = await downloadDriveFile(fileId);
    return { dataUrl: content.type === "image" ? content.data : null, blob: content.blob || null, filename };
  }

  async function loadImageElement(dataUrl) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = dataUrl;
    });
  }

  async function buildReferenceBoard(dataUrls) {
    const valid = dataUrls.filter(Boolean);
    if (!valid.length) return null;
    const images = await Promise.all(valid.map((u) => loadImageElement(u)));
    const count = images.length;
    const cols = Math.ceil(Math.sqrt(count));
    const rows = Math.ceil(count / cols);
    const cellSize = 320;
    const canvas = document.createElement("canvas");
    canvas.width = cols * cellSize;
    canvas.height = rows * cellSize;
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = "#0b0c10";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    images.forEach((img, idx) => {
      const col = idx % cols;
      const row = Math.floor(idx / cols);
      const x = col * cellSize;
      const y = row * cellSize;
      const ratio = Math.min(cellSize / img.width, cellSize / img.height);
      const w = img.width * ratio;
      const h = img.height * ratio;
      const offsetX = x + (cellSize - w) / 2;
      const offsetY = y + (cellSize - h) / 2;
      ctx.drawImage(img, offsetX, offsetY, w, h);
    });

    const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
    if (!blob) return null;
    const dataUrl = await blobToDataUrl(blob);
    return { blob, dataUrl, file: new File([blob], "reference-board.png", { type: "image/png" }) };
  }

  function setAuthStatus(message) {
    $("#auth-status-text").text(message);
  }

  function setAppLocked(locked) {
    $("#app").toggleClass("locked", locked);
    $("#auth-overlay").toggle(locked);
  }

  function ensureDriveConfigPresent() {
    if (isFileOrigin) {
      throw new Error(
        "Google OAuth blocks the file:// origin. Serve novel_studio.html from http(s) (e.g., `python3 -m http.server`) to sign in."
      );
    }
    if (window.location.protocol === "http:" && !isLocalhostOrigin) {
      throw new Error(
        "Google OAuth requires HTTPS for non-local origins. Use https://, a tunnel (ngrok/localhost.run), or http://localhost with the origin whitelisted in your OAuth client."
      );
    }
    if (isLocalhostOrigin && !loggedLocalhostHint) {
      logLine(
        `Running on ${window.location.origin}. Ensure this origin is added as an Authorized JavaScript origin on your Google OAuth client to allow localhost sign-in.`
      );
      loggedLocalhostHint = true;
    }
    if (!GOOGLE_CLIENT_ID || GOOGLE_CLIENT_ID.includes("YOUR_")) {
      throw new Error("Set GOOGLE_CLIENT_ID to a valid OAuth client id for Google Drive.");
    }
  }

  function loadGoogleScript(id, src, checkLoaded) {
    return new Promise((resolve, reject) => {
      if (checkLoaded()) {
        resolve();
        return;
      }

      let script = document.getElementById(id);
      if (script?.dataset?.sdkState === "failed") {
        script.remove();
        script = null;
      }
      const descriptor = src.includes("gsi") ? "Google Identity Services" : "Google API client";

      if (!script) {
        script = document.createElement("script");
        script.id = id;
        script.src = src;
        script.async = true;
        script.defer = true;
        document.head.appendChild(script);
      }

      script.dataset.sdkState = "loading";

      const timeout = setTimeout(() => {
        script.dataset.sdkState = "failed";
        reject(new Error(`${descriptor} script timed out while loading.`));
      }, 15000);

      const onLoad = () => {
        clearTimeout(timeout);
        if (checkLoaded()) {
          script.dataset.sdkState = "loaded";
          logLine(`${descriptor} script loaded.`);
          resolve();
        } else {
          script.dataset.sdkState = "failed";
          reject(new Error(`${descriptor} loaded but global object is missing.`));
        }
      };

      const onError = () => {
        clearTimeout(timeout);
        script.dataset.sdkState = "failed";
        reject(new Error(`${descriptor} script failed to load (network blocked or offline).`));
      };

      script.addEventListener("load", onLoad, { once: true });
      script.addEventListener("error", onError, { once: true });
    });
  }

  async function loadGoogleSdkAssets() {
    if (googleSdkLoadPromise) return googleSdkLoadPromise;
    googleSdkLoadPromise = (async () => {
      setAuthStatus("Loading Google SDK assets...");
      logLine("Loading Google SDK assets...");
      await Promise.all([
        loadGoogleScript("google-gsi-script", "https://accounts.google.com/gsi/client", () => !!window.google?.accounts),
        loadGoogleScript("google-gapi-script", "https://apis.google.com/js/api.js", () => !!window.gapi),
      ]);
      logLine("Google SDK assets downloaded. Initializing client...");
    })().catch((err) => {
      const message = err?.message || "Google SDK assets failed to load.";
      logLine("Google SDK asset load failed: " + message, true);
      setAuthStatus("Google sign-in unavailable: " + message);
      googleSdkLoadPromise = null;
      throw err;
    });
    return googleSdkLoadPromise;
  }

  async function prepareGoogleSdk() {
    if (googleDriveReady) return;
    if (!googleInitPromise) {
      googleInitPromise = (async () => {
        ensureDriveConfigPresent();
        await loadGoogleSdkAssets();
        setAuthStatus("Initializing Google Drive client...");
        await new Promise((resolve, reject) => {
          gapi.load("client", { callback: resolve, onerror: () => reject(new Error("Failed to load gapi client")) });
        });
        await gapi.client.init({ discoveryDocs: ["https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"] });
        googleDriveReady = true;
        logLine("Google Drive SDK ready.");
        setAuthStatus("Google SDK ready. Sign in to continue.");
      })().catch((err) => {
        const message = err?.message || "Google SDK failed to load";
        logLine("Google SDK initialization failed: " + message, true);
        setAuthStatus("Google sign-in unavailable: " + message);
        googleInitPromise = null;
        throw err;
      });
    }
    return googleInitPromise;
  }

  function initGoogleTokenClient() {
    if (googleTokenClient) return googleTokenClient;
    ensureDriveConfigPresent();
    googleTokenClient = google.accounts.oauth2.initTokenClient({
      client_id: GOOGLE_CLIENT_ID,
      scope: GOOGLE_SCOPES,
      callback: () => {},
    });
    return googleTokenClient;
  }

  async function requestGoogleAuth(interactive = true) {
    if (!googleDriveReady) {
      await prepareGoogleSdk();
      if (!googleDriveReady) {
        throw new Error("Google SDK is not ready yet.");
      }
    }
    initGoogleTokenClient();
    return new Promise((resolve, reject) => {
      googleTokenClient.callback = async (resp) => {
        if (resp.error) {
          setAuthStatus("Google authorization failed: " + resp.error);
          reject(new Error(resp.error));
          return;
        }
        googleAccessToken = resp.access_token;
        googleAuthorized = true;
        gapi.client.setToken({ access_token: googleAccessToken });
        await fetchGoogleProfile();
        setAuthStatus("Authorized. Loading Drive projects...");
        resolve(resp);
      };
      googleTokenClient.requestAccessToken({ prompt: interactive ? "consent" : "" });
    });
  }

  async function ensureGoogleAuthorized() {
    if (googleAuthorized && googleAccessToken) return true;
    try {
      await requestGoogleAuth(true);
      return true;
    } catch (e) {
      logLine("Google auth required: " + e.message, true);
      return false;
    }
  }

  async function fetchGoogleProfile() {
    if (!googleAccessToken) return null;
    try {
      const res = await fetch("https://www.googleapis.com/oauth2/v3/userinfo", {
        headers: { Authorization: "Bearer " + googleAccessToken },
      });
      if (res.ok) {
        const data = await res.json();
        googleUserEmail = data.email || null;
      }
    } catch (e) {
      // ignore profile fetch failures
    }
  }

  async function driveFetch(path, options = {}, upload = false) {
    if (!googleAccessToken) throw new Error("Google Drive token missing");
    const base = upload ? "https://www.googleapis.com/upload/drive/v3" : "https://www.googleapis.com/drive/v3";
    const headers = options.headers || {};
    headers["Authorization"] = "Bearer " + googleAccessToken;
    const res = await fetch(base + path, { ...options, headers });
    if (!res.ok) {
      const text = await res.text();
      throw new Error(`Drive API error (${res.status}): ${text}`);
    }
    return res;
  }

  async function listDriveFolders(query) {
    const params = new URLSearchParams({
      q: query,
      fields: "files(id,name,parents,mimeType,modifiedTime)",
      spaces: "drive",
      pageSize: 1000,
    });
    const res = await driveFetch(`/files?${params.toString()}`);
    const data = await res.json();
    return data.files || [];
  }

  async function findOrCreateChildFolder(parentId, name) {
    const query = `'${parentId}' in parents and mimeType='application/vnd.google-apps.folder' and name='${name.replace("'", "\\'")}' and trashed=false`;
    const folders = await listDriveFolders(query);
    if (folders.length) return folders[0];
    const metadata = { name, mimeType: "application/vnd.google-apps.folder", parents: [parentId] };
    const body = new Blob([JSON.stringify(metadata)], { type: "application/json" });
    const res = await driveFetch("/files", { method: "POST", headers: { "Content-Type": "application/json" }, body }, false);
    const created = await res.json();
    return created;
  }

  async function findChildFolder(parentId, name) {
    const query = `'${parentId}' in parents and mimeType='application/vnd.google-apps.folder' and name='${name.replace("'", "\\'")}' and trashed=false`;
    const folders = await listDriveFolders(query);
    return folders[0] || null;
  }

  async function uploadBlobToDrive(filename, blob, parentId, existingId = null) {
    const boundary = "-------314159265358979323846";
    const delimiter = "\r\n--" + boundary + "\r\n";
    const closeDelimiter = "\r\n--" + boundary + "--";
    const metadata = { name: filename, parents: [parentId] };
    const multipartBody =
      delimiter +
      "Content-Type: application/json; charset=UTF-8\r\n\r\n" +
      JSON.stringify(metadata) +
      delimiter +
      "Content-Type: " + (blob.type || "application/octet-stream") + "\r\n\r\n" +
      "";

    const reader = await blob.arrayBuffer();
    const body = new Uint8Array(multipartBody.length + reader.byteLength + closeDelimiter.length);
    let offset = 0;
    for (let i = 0; i < multipartBody.length; i++) body[offset++] = multipartBody.charCodeAt(i);
    body.set(new Uint8Array(reader), offset);
    offset += reader.byteLength;
    for (let i = 0; i < closeDelimiter.length; i++) body[offset++] = closeDelimiter.charCodeAt(i);

    const path = existingId
      ? `/files/${existingId}?uploadType=multipart`
      : "/files?uploadType=multipart";
    const res = await driveFetch(path, {
      method: existingId ? "PATCH" : "POST",
      headers: { "Content-Type": "multipart/related; boundary=" + boundary },
      body,
    }, true);
    return await res.json();
  }

  async function moveDriveFileToFolder(fileId, targetParentId, previousParentId) {
    const params = new URLSearchParams();
    if (targetParentId) params.append("addParents", targetParentId);
    if (previousParentId) params.append("removeParents", previousParentId);
    params.append("fields", "id,parents");
    const res = await driveFetch(`/files/${fileId}?${params.toString()}`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: "{}",
    });
    return await res.json();
  }

  function recordImageCache(fileId, dataUrl, blob, contentType) {
    if (!fileId || !dataUrl || imageCache.has(fileId)) return;
    imageCache.set(fileId, { dataUrl, blob, contentType });
  }

  async function downloadDriveFile(fileId) {
    if (imageCache.has(fileId)) {
      const cached = imageCache.get(fileId);
      return { type: "image", data: cached.dataUrl, contentType: cached.contentType || "image/*", blob: cached.blob };
    }
    const res = await driveFetch(`/files/${fileId}?alt=media`, {}, false);
    const contentType = res.headers.get("content-type") || "";
    const blob = await res.blob();
    if (contentType.startsWith("image/")) {
      const dataUrl = await blobToDataUrl(blob);
      recordImageCache(fileId, dataUrl, blob, contentType);
      return { type: "image", data: dataUrl, contentType, blob };
    }
    const text = await blob.text();
    return { type: "text", data: text, contentType, blob };
  }

  async function warmImageCacheForDocs(docs = []) {
    const imageDocs = (docs || []).filter((d) => (d.mimeType || "").startsWith("image/"));
    for (const doc of imageDocs) {
      if (imageCache.has(doc.id)) continue;
      try {
        await downloadDriveFile(doc.id);
      } catch (e) {
        logLine(`Image cache warm failed for ${doc.name || doc.filename}: ${e.message}`, true);
      }
    }
  }

  async function deleteDriveFile(fileId) {
    await driveFetch(`/files/${fileId}`, { method: "DELETE" });
  }

  function appendToConsole($content, isError = false) {
    const $line = $("<div>").addClass("line");
    if (isError) $line.addClass("error");
    $line.append($content);
    $("#console-log").append($line);
    $("#console-log").scrollTop($("#console-log")[0].scrollHeight);
  }

  function logLine(message, isError = false) {
    const prefix = isError ? "[ERR]" : "[LOG]";
    const $content = $("<span>");
    $content.append($("<span>").addClass("prefix").text(prefix + " "));
    $content.append(document.createTextNode(message));
    appendToConsole($content, isError);
  }

  function logLink(label, url, downloadName = null) {
    const $content = $("<span>");
    $content.append($("<span>").addClass("prefix").text("[LINK] "));
    const $anchor = $("<a>").addClass("download-link").attr("href", url).attr("target", "_blank").text(label);
    if (downloadName) {
      $anchor.attr("download", downloadName);
    }
    $content.append($anchor);
    appendToConsole($content, false);
  }

  let activeRequests = 0;
  let longLoadingHolds = 0;

  function updateLoadingIndicator() {
    $("#loading-indicator").toggleClass("visible", activeRequests > 0 || longLoadingHolds > 0);
  }

  function beginLoading() {
    activeRequests += 1;
    updateLoadingIndicator();
  }

  function endLoading() {
    activeRequests = Math.max(0, activeRequests - 1);
    updateLoadingIndicator();
  }

  function beginLongLoading() {
    longLoadingHolds += 1;
    updateLoadingIndicator();
  }

  function endLongLoading() {
    longLoadingHolds = Math.max(0, longLoadingHolds - 1);
    updateLoadingIndicator();
  }

  function setStatus(message) {
    $("#status-bar").text(message);
  }

  function fetchWithTimeout(url, options, label = "request") {
    const controller = new AbortController();
    const merged = { ...options, signal: controller.signal };
    beginLoading();
    logLine(`Sending ${label}...`);
    const waitInterval = setInterval(() => logLine(`Waiting on ${label}...`), 15000);
    const timeoutId = setTimeout(() => {
      controller.abort();
      logLine(`${label} timed out after 5 minutes.`, true);
    }, 300000);
    return fetch(url, merged)
      .then((res) => {
        logLine(`${label} response received.`);
        return res;
      })
      .catch((err) => {
        if (err.name === "AbortError") {
          logLine(`${label} was cancelled or timed out.`, true);
          setStatus(`${label} cancelled. Please retry.`);
        } else {
          logLine(`${label} failed: ${err.message}`, true);
          setStatus(`${label} failed. Check connection and try again.`);
        }
        throw err;
      })
      .finally(() => {
        clearInterval(waitInterval);
        clearTimeout(timeoutId);
        endLoading();
      });
  }

  function loadProjectsFromStorage() {
    try {
      const raw = localStorage.getItem(PROJECTS_KEY);
      const parsed = raw ? JSON.parse(raw) : {};
      projects = {};
      Object.entries(parsed).forEach(([key, value]) => {
        const cleanName = key.replace(/^novel -/i, "").trim();
        const normalized = { ...(value || {}), name: (value && value.name) || cleanName };
        projects[cleanName] = ensureProjectStructure(normalized);
      });
    } catch (e) {
      logLine("Failed to load projects from localStorage: " + e, true);
      projects = {};
    }
  }

  function updateModelStatus() {
    $("#model-status").text(`Using: ${assistantModel}`);
  }

  async function listProjectFoldersFromDrive() {
    const query = `mimeType='application/vnd.google-apps.folder' and name contains '${PROJECT_PREFIX}' and trashed=false`;
    const folders = await listDriveFolders(query);
    return (folders || []).filter((f) => (f.name || "").toLowerCase().startsWith(PROJECT_PREFIX.toLowerCase()));
  }

  function rememberDriveMapping(project, category, driveId, fileId) {
    project.driveMappings = project.driveMappings || {};
    project.driveMappings[category] = project.driveMappings[category] || {};
    project.driveMappings[category][driveId] = fileId;
    saveProjectsToStorage();
  }

  function forgetDriveMapping(project, category, driveId) {
    if (project.driveMappings?.[category]) {
      delete project.driveMappings[category][driveId];
      saveProjectsToStorage();
    }
  }

  async function getOrCreateProjectFolder(project) {
    ensureProjectStructure(project);
    if (project.drive?.rootId) return project.drive.rootId;
    const folders = await listProjectFoldersFromDrive();
    const match = folders.find((f) => f.name === PROJECT_PREFIX + project.name);
    if (match) {
      project.drive.rootId = match.id;
      saveProjectsToStorage();
      return match.id;
    }
    const metadata = { name: PROJECT_PREFIX + project.name, mimeType: "application/vnd.google-apps.folder" };
    const body = new Blob([JSON.stringify(metadata)], { type: "application/json" });
    const res = await driveFetch("/files", { method: "POST", headers: { "Content-Type": "application/json" }, body });
    const created = await res.json();
    project.drive.rootId = created.id;
    saveProjectsToStorage();
    return created.id;
  }

  async function ensureCategoryFolder(project, category) {
    ensureProjectStructure(project);
    project.drive.categoryFolders = project.drive.categoryFolders || {};
    if (project.drive.categoryFolders[category]) return project.drive.categoryFolders[category];
    const rootId = await getOrCreateProjectFolder(project);
    const folder = await findOrCreateChildFolder(rootId, category);
    project.drive.categoryFolders[category] = folder.id;
    saveProjectsToStorage();
    return folder.id;
  }

  async function ensureCharacterFolder(project, characterName) {
    const catRoot = await ensureCategoryFolder(project, CHARACTER_CATEGORY);
    project.drive.characterFolders = project.drive.characterFolders || {};
    if (project.drive.characterFolders[characterName]) return project.drive.characterFolders[characterName];
    const folder = await findOrCreateChildFolder(catRoot, characterName);
    project.drive.characterFolders[characterName] = folder.id;
    saveProjectsToStorage();
    return folder.id;
  }

  async function ensureCharacterDraftsFolder(project, characterName) {
    const characterRoot = await ensureCharacterFolder(project, characterName);
    project.drive.characterDraftFolders = project.drive.characterDraftFolders || {};
    if (project.drive.characterDraftFolders[characterName]) return project.drive.characterDraftFolders[characterName];
    const draftsFolder = await findOrCreateChildFolder(characterRoot, "drafts");
    project.drive.characterDraftFolders[characterName] = draftsFolder.id;
    saveProjectsToStorage();
    return draftsFolder.id;
  }

  async function ensureProjectDriveStructure(project) {
    await getOrCreateProjectFolder(project);
    for (const cat of CATEGORY_FOLDERS) {
      await ensureCategoryFolder(project, cat);
    }
  }

  async function listDriveFiles(parentId) {
    const params = new URLSearchParams({
      q: `'${parentId}' in parents and trashed=false`,
      fields: "files(id,name,mimeType,modifiedTime,size,parents)",
      pageSize: 1000,
    });
    const res = await driveFetch(`/files?${params.toString()}`);
    const data = await res.json();
    return data.files || [];
  }

  async function autoOrganizeCharacterDocs(project) {
    const charactersRoot = await ensureCategoryFolder(project, CHARACTER_CATEGORY);
    const files = await listDriveFiles(charactersRoot);
    const candidates = files.filter((f) => f.mimeType !== "application/vnd.google-apps.folder");
    if (!candidates.length) return;
    const knownChars = Object.keys(project.characters || {});
    for (const file of candidates) {
      const matchName = knownChars.find((c) => file.name.toLowerCase().includes(c.toLowerCase()));
      if (!matchName) continue;
      const targetFolder = await ensureCharacterFolder(project, matchName);
      await driveFetch(`/files/${file.id}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ addParents: targetFolder, removeParents: charactersRoot }),
      });
      logLine(`Moved ${file.name} into ${matchName} folder.`);
    }
  }

  async function syncProjectsFromDrive() {
    const folders = await listProjectFoldersFromDrive();
    folders.forEach((folder) => {
      const name = folder.name.replace(PROJECT_PREFIX, "").trim();
      projects[name] = ensureProjectStructure(projects[name] || { name });
      projects[name].name = name;
      projects[name].drive.rootId = folder.id;
    });
    saveProjectsToStorage();
    refreshProjectListUI();
    return folders;
  }

  function loadModelPreference() {
    try {
      const saved = localStorage.getItem(MODEL_KEY);
      if (saved && ASSISTANT_MODELS.includes(saved)) {
        assistantModel = saved;
      }
      $("#model-select").val(assistantModel);
      updateModelStatus();
      localStorage.setItem(MODEL_KEY, assistantModel);
    } catch (e) {
      logLine("Failed to load model preference: " + e, true);
    }
  }

  function setAssistantModel(model) {
    if (!ASSISTANT_MODELS.includes(model)) {
      logLine("Unsupported model selection: " + model, true);
      $("#model-select").val(assistantModel);
      return;
    }
    assistantModel = model;
    localStorage.setItem(MODEL_KEY, assistantModel);
    updateModelStatus();
    logLine("Assistant model set to " + assistantModel + ".");
  }

  function setProjectPickerStatus(message) {
    $("#project-picker-status").text(message);
  }

  function hideProjectPicker(result = null) {
    $("#project-picker-overlay").removeClass("visible");
    projectPickerSelection = null;
    if (projectPickerResolver) {
      const resolve = projectPickerResolver;
      projectPickerResolver = null;
      resolve(result);
    }
  }

  function renderProjectPickerRows(folders = [], preferred = null) {
    const $list = $("#project-picker-list");
    $list.empty();
    if (!folders.length) {
      $list.append(
        $("<div>")
          .addClass("project-picker-row")
          .text("No Google Drive folders found that begin with 'novel - '. Create one to continue.")
      );
      projectPickerSelection = null;
      return;
    }

    const normalizedPref = preferred ? preferred.toLowerCase() : null;
    folders.forEach((folder) => {
      const name = folder.name.replace(PROJECT_PREFIX, "").trim();
      const $row = $("<div>").addClass("project-picker-row");
      const $label = $("<div>")
        .css({ display: "flex", flexDirection: "column" })
        .append($("<strong>").text(folder.name))
        .append($("<span>").css("color", "#c5c6c7").text(folder.id));
      const $radio = $("<input type='radio' name='project-picker-choice'>").val(name);
      if (normalizedPref && name.toLowerCase() === normalizedPref) {
        $radio.prop("checked", true);
        $row.addClass("selected");
        projectPickerSelection = name;
      }
      $radio.on("change", function () {
        projectPickerSelection = $(this).val();
        $(".project-picker-row").removeClass("selected");
        $row.addClass("selected");
      });
      $row.append($label, $radio);
      $list.append($row);
    });

    if (!projectPickerSelection && folders.length) {
      projectPickerSelection = folders[0].name.replace(PROJECT_PREFIX, "").trim();
      $list.find("input[name='project-picker-choice']").first().prop("checked", true);
      $list.find(".project-picker-row").first().addClass("selected");
    }
  }

  async function refreshProjectPicker(preferred = null) {
    try {
      setProjectPickerStatus("Loading Drive projects...");
      const folders = await syncProjectsFromDrive();
      const sorted = (folders || []).sort((a, b) => a.name.localeCompare(b.name));
      renderProjectPickerRows(sorted, preferred);
      setProjectPickerStatus("Select a Drive project to use as your workspace.");
    } catch (e) {
      setProjectPickerStatus("Failed to load Drive projects: " + e.message);
      logLine("Project picker load failed: " + e.message, true);
    }
  }

  function showProjectPicker(preferred = null) {
    return new Promise((resolve) => {
      projectPickerResolver = resolve;
      $("#project-picker-overlay").addClass("visible");
      refreshProjectPicker(preferred);
    });
  }

  function setConsoleExpanded(expanded) {
    consoleExpanded = expanded;
    $("#console-panel").toggleClass("expanded", expanded);
    $("#console-panel-title").text(expanded ? "Console (expanded)" : "Console (collapsed)");
    $("#console-toggle-btn").text(expanded ? "Collapse" : "Expand");
  }

  function saveProjectsToStorage() {
    try {
      localStorage.setItem(PROJECTS_KEY, JSON.stringify(projects));
    } catch (e) {
      logLine("Failed to save projects to localStorage: " + e, true);
    }
  }

  function refreshProjectListUI() {
    const $list = $("#project-list");
    $list.empty();
    const names = Object.keys(projects).sort();
    if (names.length === 0) {
      $list.append($("<div>").text("(no projects yet)"));
      return;
    }
    names.forEach((name) => {
      const $item = $("<div>").addClass("project-item");
      const displayName = PROJECT_PREFIX + name;
      const $name = $("<span>").addClass("project-name").text(displayName);
      $name.on("click", async () => {
        await selectProject(name);
      });

      const $actions = $("<span>").addClass("project-actions");
      const $loadBtn = $("<button>").text("Load").on("click", async () => {
        await selectProject(name);
      });
      $actions.append($loadBtn);

      $item.append($name).append($actions);
      $list.append($item);
    });
  }

  function ensureProjectStructure(project) {
    if (project.name) project.name = project.name.replace(/^novel -/i, "").trim();
    if (!project.assistants) project.assistants = {};
    if (!project.vectorStores) project.vectorStores = {};
    if (!project.outlines) project.outlines = {};
    if (!project.chapters) project.chapters = {};
    if (!project.storyArc) project.storyArc = null;
    if (!project.characters) project.characters = {};
    if (!project.drive) project.drive = { rootId: null, categoryFolders: {}, characterFolders: {}, characterDraftFolders: {} };
    project.drive.categoryFolders = project.drive.categoryFolders || {};
    project.drive.characterFolders = project.drive.characterFolders || {};
    project.drive.characterDraftFolders = project.drive.characterDraftFolders || {};
    if (!project.driveMappings) project.driveMappings = {};
    return project;
  }

  function ensureCharacterRecord(project, name) {
    const cleanName = (name || "").trim();
    if (!cleanName) return null;
    project.characters = project.characters || {};
    if (!project.characters[cleanName]) {
      project.characters[cleanName] = {
        sheet: null,
        photos: [],
        draftPhotos: [],
        settings: null,
      };
    }
    return project.characters[cleanName];
  }

  function highlightSelectedCharacterCard() {
    const $cards = $("#character-grid .character-card");
    $cards.removeClass("selected");
    if (!currentCharacterName) return;
    $cards.each(function () {
      const name = $(this).data("name");
      if (name === currentCharacterName) {
        $(this).addClass("selected");
      }
    });
  }

  function setCharacterMode(mode) {
    characterConversationMode = mode === "chat" ? "chat" : "edit";
    const editing = characterConversationMode === "edit";
    $("#character-mode-toggle button").removeClass("active");
    $(`#character-mode-toggle button[data-mode='${characterConversationMode}']`).addClass("active");
    $("#canvas-document").attr("contenteditable", editing);
    const placeholder = editing
      ? "Ask the assistant to adjust this sheet..."
      : "Ask questions about this character without editing their sheet...";
    $("#canvas-user-prompt").attr("placeholder", placeholder);
  }

  function refreshCharacterSelectUI(project) {
    $("#current-character-name").text(currentCharacterName || "None");
  }

  function setCurrentCharacter(project, name) {
    const cleanName = (name || "").trim();
    if (!cleanName) {
      currentCharacterName = null;
      refreshCharacterSelectUI(project);
      $("#canvas-character-name").text("None");
      logLine("Cleared current character selection.");
      return;
    }
    ensureCharacterRecord(project, cleanName);
    currentCharacterName = cleanName;
    saveProjectsToStorage();
    refreshCharacterSelectUI(project);
    highlightSelectedCharacterCard();
    logLine("Working on character: " + cleanName);
  }

  async function selectProject(name) {
    if (!projects[name]) {
      logLine("Project not found: " + name, true);
      return;
    }
    if (!googleAuthorized) {
      alert("Sign in with Google Drive first.");
      return;
    }
    const project = ensureProjectStructure(projects[name]);
    currentProjectName = name;
    $("#current-project-name").text(PROJECT_PREFIX + project.name);
    currentCharacterName = null;
    resetCharacterCanvasSession();
    hideCharacterCanvas();
    ensureDocPreviewMessage();
    try {
      await ensureProjectDriveStructure(project);
      await autoOrganizeCharacterDocs(project);
      await alignVectorStoresToDrive(project);
    } catch (e) {
      logLine("Drive setup failed: " + e.message, true);
    }
    refreshCharacterSelectUI(project);
    refreshCharacterRoster(project, true).catch((e) => {
      logLine("Could not refresh character roster: " + e.message, true);
    });
    refreshStoryTargetSelectors(project, true);
    logLine("Switched to project: " + name);
    setStatus("Project " + name + " loaded.");
    const setupOpen = document.getElementById("setup-docs-panel")?.open;
    if (setupOpen) {
      showDocCanvas(project, $("#doc-category-select").val());
    } else {
      hideDocCanvas();
    }
    initAssistantsForProject(project)
      .catch((e) => {
        logLine("Auto-initialize assistants failed: " + e.message, true);
      })
      .finally(() => {
        setStatus(`Project ${name} ready.`);
      });
  }

  function exitDriveProject() {
    currentProjectName = null;
    $("#current-project-name").text("None");
    hideCharacterCanvas();
    resetCharacterCanvasSession();
    ensureDocPreviewMessage("Select a Drive project to see its documents.");
    refreshCharacterSelectUI({ characters: {} });
    refreshProjectListUI();
    setStatus("No Drive project selected.");
    logLine("Exited current Drive project. Pick another to continue.");
  }

  async function createProject(rawName) {
    const authed = await ensureGoogleAuthorized();
    if (!authed) return null;
    let cleanName = (rawName || "").trim();
    if (!cleanName) {
      cleanName = "untitled";
    }
    cleanName = cleanName.replace(/^novel -/i, "").trim();
    if (projects[cleanName]) {
      alert("Project already exists with that name.");
      return null;
    }
    projects[cleanName] = ensureProjectStructure({ name: cleanName });
    await ensureProjectDriveStructure(projects[cleanName]);
    saveProjectsToStorage();
    refreshProjectListUI();
    refreshCharacterSelectUI(projects[cleanName]);
    return cleanName;
  }

  async function promptForDriveProjectSelection() {
    const existing = Object.keys(projects || {});
    const preferred = currentProjectName && projects[currentProjectName] ? currentProjectName : existing[0] || null;
    const choice = await showProjectPicker(preferred);
    if (choice && projects[choice]) {
      await selectProject(choice);
      const who = googleUserEmail ? ` (${googleUserEmail})` : "";
      setAuthStatus(`Connected to Google Drive${who}. Using ${PROJECT_PREFIX + choice}.`);
      setAppLocked(false);
      return true;
    }
    setAuthStatus("Drive connected. No project selected.");
    setStatus("Choose a Drive project to begin.");
    setAppLocked(false);
    return false;
  }

  function getCurrentProject() {
    if (!currentProjectName || !projects[currentProjectName]) {
      logLine("No project loaded.", true);
      return null;
    }
    return ensureProjectStructure(projects[currentProjectName]);
  }

  // ==============================
  // OPENAI API HELPERS
  // ==============================

  function requireApiKey() {
    if (!apiKey) {
      logLine("API key not set. Please enter and set your OpenAI API key.", true);
      return false;
    }
    return true;
  }

  async function openaiJson(path, method = "POST", body = null, useAssistantsBeta = false, label = null) {
    if (!requireApiKey()) throw new Error("No API key");
    const headers = {
      "Authorization": "Bearer " + apiKey,
      "Content-Type": "application/json",
    };
    if (useAssistantsBeta) {
      headers["OpenAI-Beta"] = "assistants=v2";
    }
    const requestLabel = label || `OpenAI ${method} ${path}`;
    const res = await fetchWithTimeout("https://api.openai.com/v1" + path, {
      method: method,
      headers: headers,
      body: body ? JSON.stringify(body) : null,
    }, requestLabel);
    if (!res.ok) {
      const text = await res.text();
      throw new Error("OpenAI API error (" + res.status + "): " + text);
    }
    return await res.json();
  }

  async function openaiFormData(path, formData, useAssistantsBeta = false, label = null) {
    if (!requireApiKey()) throw new Error("No API key");
    const headers = {
      "Authorization": "Bearer " + apiKey,
    };
    if (useAssistantsBeta) {
      headers["OpenAI-Beta"] = "assistants=v2";
    }
    const requestLabel = label || `OpenAI POST ${path}`;
    const res = await fetchWithTimeout("https://api.openai.com/v1" + path, {
      method: "POST",
      headers: headers, // don't set Content-Type manually; browser will
      body: formData,
    }, requestLabel);
    if (!res.ok) {
      const text = await res.text();
      throw new Error("OpenAI API error (" + res.status + "): " + text);
    }
    return await res.json();
  }

  async function openaiAudio(path, body, label = null) {
    if (!requireApiKey()) throw new Error("No API key");
    const headers = {
      "Authorization": "Bearer " + apiKey,
      "Content-Type": "application/json",
    };
    const requestLabel = label || `OpenAI audio POST ${path}`;
    const res = await fetchWithTimeout("https://api.openai.com/v1" + path, {
      method: "POST",
      headers: headers,
      body: JSON.stringify(body),
    }, requestLabel);
    if (!res.ok) {
      const text = await res.text();
      throw new Error("OpenAI Audio API error (" + res.status + "): " + text);
    }
    // Expect binary audio
    return await res.blob();
  }

  function blobToDataUrl(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }

  async function fetchOpenAIFileContent(fileId) {
    if (!requireApiKey()) throw new Error("No API key");
    const headers = {
      Authorization: "Bearer " + apiKey,
    };
    const res = await fetchWithTimeout(
      `https://api.openai.com/v1/files/${fileId}/content`,
      { method: "GET", headers },
      `download file ${fileId}`
    );
    if (!res.ok) {
      const text = await res.text();
      throw new Error("OpenAI file download error (" + res.status + "): " + text);
    }
    const contentType = res.headers.get("content-type") || "";
    const blob = await res.blob();
    if (contentType.startsWith("image/")) {
      const dataUrl = await blobToDataUrl(blob);
      return { type: "image", data: dataUrl, contentType, blob };
    }
    const text = await blob.text();
    return { type: "text", data: text, contentType, blob };
  }

  async function editImageWithPrompt(baseFile, promptText) {
    const formData = new FormData();
    formData.append("model", "gpt-image-1");
    formData.append("image", baseFile);
    formData.append("prompt", promptText || "Enhance the portrait.");
    formData.append("size", "1024x1024");
    const res = await openaiFormData("/images/edits", formData, false);
    const b64 = res?.data?.[0]?.b64_json;
    if (!b64) {
      throw new Error("No edited image returned from OpenAI");
    }
    return "data:image/png;base64," + b64;
  }

  async function runAssistantOnce(assistantId, userText) {
    beginLongLoading();
    try {
      // Use combined thread+run creation endpoint:
      // POST /v1/threads/runs with {assistant_id, thread: {messages:[...]}}
      logLine("Preparing assistant run " + assistantId + "...");
      const body = {
        assistant_id: assistantId,
        thread: {
          messages: [
            {
              role: "user",
              content: userText,
            },
          ],
        },
      };
      const runObj = await openaiJson("/threads/runs", "POST", body, true, `assistant run ${assistantId}`);
      const threadId = runObj.thread_id;
      const runId = runObj.id;

      const waitInterval = setInterval(() => logLine(`Waiting on assistant ${assistantId}...`), 15000);
      const waitTimeout = setTimeout(() => {
        logLine(`Assistant ${assistantId} run exceeded 5 minutes; aborting.`, true);
      }, 300000);

      // Poll run until completed
      let attempts = 0;
      while (true) {
        attempts++;
        const run = await openaiJson(
          `/threads/${threadId}/runs/${runId}`,
          "GET",
          null,
          true,
          `assistant status ${assistantId}`
        );
        if (run.status === "completed") {
          break;
        }
        if (["failed", "cancelled", "expired"].includes(run.status)) {
          clearInterval(waitInterval);
          clearTimeout(waitTimeout);
          throw new Error("Run ended with status: " + run.status);
        }
        if (attempts > 60) {
          clearInterval(waitInterval);
          clearTimeout(waitTimeout);
          throw new Error("Run polling timed out.");
        }
        await new Promise((resolve) => setTimeout(resolve, 2000));
      }

      clearInterval(waitInterval);
      clearTimeout(waitTimeout);
      // Retrieve messages
      const msgs = await openaiJson(
        `/threads/${threadId}/messages?limit=20`,
        "GET",
        null,
        true,
        `assistant messages ${assistantId}`
      );
      if (!msgs.data || msgs.data.length === 0) {
        return "";
      }
      // Find first assistant message
      for (const msg of msgs.data) {
        if (msg.role === "assistant") {
          let textParts = [];
          for (const c of msg.content || []) {
            if (c.type === "text" && c.text && c.text.value) {
              textParts.push(c.text.value);
            }
          }
          return textParts.join("\n").trim();
        }
      }
      return "";
    } finally {
      endLongLoading();
    }
  }

  // ==============================
  // OPENAI RESOURCES (ASSISTANTS, VECTOR STORES, FILES)
  // ==============================

  async function ensureVectorStore(project, category) {
    project.vectorStores = project.vectorStores || {};
    if (project.vectorStores[category]) return project.vectorStores[category];

    const res = await openaiJson("/vector_stores", "POST", {
      name: project.name + " [" + category + "]",
    }, true);
    const vsId = res.id;
    project.vectorStores[category] = vsId;
    logLine("Created vector store for '" + category + "': " + vsId);
    saveProjectsToStorage();
    return vsId;
  }

  async function uploadFileToOpenAI(file) {
    const form = new FormData();
    form.append("purpose", "assistants");
    form.append("file", file, file.name);
    const res = await openaiFormData("/files", form, true);
    return res; // {id, ...}
  }

  async function attachFileToVectorStore(vsId, fileId) {
    return await openaiJson(`/vector_stores/${vsId}/files`, "POST", {
      file_id: fileId,
    }, true);
  }

  async function listVectorStoreFiles(vsId) {
    return await openaiJson(`/vector_stores/${vsId}/files`, "GET", null, true);
  }

  async function deleteVectorStoreFile(vsId, fileId) {
    return await openaiJson(`/vector_stores/${vsId}/files/${fileId}`, "DELETE", null, true);
  }

  async function deleteOpenAIFile(fileId) {
    return await openaiJson(`/files/${fileId}`, "DELETE", null, true);
  }

  async function retrieveOpenAIFile(fileId) {
    return await openaiJson(`/files/${fileId}`, "GET", null, true);
  }

  async function createOrGetAssistant(project, roleName, instructions, useFileSearch) {
    project.assistants = project.assistants || {};
    const expectedTools = [];
    let toolResources = undefined;
    if (useFileSearch) {
      const vsIds = Object.values(project.vectorStores || {});
      expectedTools.push({ type: "file_search" });
      toolResources = {
        file_search: {
          vector_store_ids: vsIds,
        },
      };
    }

    const existingId = project.assistants[roleName];
    if (existingId) {
      try {
        const assistant = await openaiJson(`/assistants/${existingId}`, "GET", null, true);
        const existingTools = (assistant.tools || []).map((t) => t.type).sort().join(",");
        const expectedToolTypes = expectedTools.map((t) => t.type).sort().join(",");
        const existingVs = assistant.tool_resources?.file_search?.vector_store_ids || [];
        const expectedVs = toolResources?.file_search?.vector_store_ids || [];

        const needsUpdate =
          (assistant.instructions || "").trim() !== instructions.trim() ||
          assistant.model !== assistantModel ||
          existingTools !== expectedToolTypes ||
          JSON.stringify([...existingVs].sort()) !== JSON.stringify([...expectedVs].sort());

        if (needsUpdate) {
          const updateBody = {
            instructions: instructions,
            model: assistantModel,
            tools: expectedTools,
          };
          if (toolResources) {
            updateBody.tool_resources = toolResources;
          }
          await openaiJson(`/assistants/${existingId}`, "POST", updateBody, true, `update assistant ${roleName}`);
          logLine(`Updated assistant '${roleName}' configuration.`);
        } else {
          logLine(`Assistant '${roleName}' already configured.`);
        }
        return existingId;
      } catch (e) {
        logLine(`Assistant '${roleName}' lookup failed; recreating. Error: ${e.message}`, true);
      }
    }

    const body = {
      name: project.name + " [" + roleName + "]",
      instructions: instructions,
      model: assistantModel,
      tools: expectedTools,
    };
    if (toolResources) {
      body.tool_resources = toolResources;
    }
    const res = await openaiJson("/assistants", "POST", body, true);
    project.assistants[roleName] = res.id;
    saveProjectsToStorage();
    logLine("Created assistant '" + roleName + "': " + res.id);
    return res.id;
  }

  async function initAssistantsForProject(project) {
    setStatus("Initializing assistants...");
    logLine("Initializing assistants for project: " + project.name);

    const loreInstructions = `
You are the definitive lorekeeper for this novel project.
Use file_search to consult character sheets, locations, relationships,
storyline, history, and outlines.

Rules:
- Treat uploaded documents as canonical.
- When conflicts exist, prefer the latest or most detailed doc.
- Be specific and grounded.
- If unsure, explicitly mark information as uncertain.
`.trim();

    const architectInstructions = `
You are the SERIES ARCHITECT for a high dark fantasy trilogy.
Tone: Witcher / LOTR / D&D, with strong romance, found family, and emotional angst.

Task:
- Using all accessible lore and notes, propose a clean 3-book structure.
- For each book:
  - Premise & primary conflict
  - Thematic focus
  - Protagonist's emotional arc
  - Key supporting character arcs
  - 6–10 tentpole events.
`.trim();

    const outlinerInstructions = `
You are the BOOK OUTLINER for this trilogy.

You must ALWAYS output a single JSON object following this exact structure:

{
  "book_number": <int>,
  "title": "<working title>",
  "acts": [
    {
      "act_number": <int>,
      "act_title": "<string>",
      "chapters": [
        {
          "chapter_number": <int>,
          "chapter_title": "<string>",
          "pov": "<character name>",
          "location": "<string>",
          "summary": "<2–6 sentence summary>",
          "emotional_goal": "<emotional purpose of chapter>",
          "target_words": <int>,
          "scene_beats": ["beat1", "beat2", "..."]
        }
      ]
    }
  ]
}

Rules:
- ALWAYS output valid JSON.
- DO NOT include commentary or explanation outside the JSON.
- Maintain the dark fantasy tone in summaries and beats,
  but the output must remain syntactically valid JSON.
`.trim();

    const drafterInstructions = `
You are the CHAPTER DRAFTER.
You take structured chapter beats and turn them into full scenes.

Rules:
- Close third-person POV, deep in the specified character's head.
- Respect lore, relationships, injuries, and magic rules.
- Make scenes vivid and emotional without purple prose.
- Maintain continuity with prior chapters if context is provided.
`.trim();

    const lineEditorInstructions = `
You are a LINE & PROSE EDITOR.
Given a draft chapter:
- Improve clarity, pacing, flow, and dialogue.
- Remove repetition, sharpen descriptions.
- Preserve events, POV, and emotional beats.
- Keep the established voice and tense.
Output ONLY the edited chapter text.
`.trim();

    const continuityInstructions = `
You are the CONTINUITY EDITOR.
Use file_search to cross-check a chapter against lore and previous material.

Steps:
1) List continuity issues (numbered) and proposed fixes.
2) Output a corrected version of the chapter incorporating those fixes.

Check:
- Character details (appearance, injuries, knowledge, personality)
- Magic rules & limitations
- Geography, timeline, history
- Relationship and emotional continuity
`.trim();

    const bookReviewerInstructions = `
You are the BOOK-LEVEL REVIEWER.
You read multiple chapters and evaluate:

- Overall plot coherence and pacing
- Thematic unity
- Character arc consistency
- Romantic / emotional through-lines
- Tone and voice consistency
- Structural issues (dragging sections, missing setup/payoff)

Provide:
- A high-level summary of the current book as written.
- A bullet list of major strengths.
- A bullet list of major issues.
- Concrete suggestions for restructuring or tightening the narrative.
`.trim();

    const characterDesignerInstructions = `
You are the CHARACTER DESIGNER and SHEET EDITOR.
Use file_search to consult lore, outlines, and prior sheets.

When asked to draft or refine a character sheet:
- Respect established canon and note uncertainties.
- Keep the sheet concise but complete: identity, appearance, voice, skills, relationships, secrets, goals, and conflicts.
- Output full text that can be saved directly as a sheet.
- Maintain the naming convention "[Name] Character Sheet.[ext]" where ext is txt or docx.

When asked about photos:
- Provide brief visual guidance for portraits consistent with the character sheet.
- Be explicit about face angle, lighting, expression, and hair details for profile shots.
`.trim();

    project.vectorStores = project.vectorStores || {};

    await createOrGetAssistant(project, "LoreKeeper", loreInstructions, true);
    await createOrGetAssistant(project, "SeriesArchitect", architectInstructions, true);
    await createOrGetAssistant(project, "BookOutliner", outlinerInstructions, true);
    await createOrGetAssistant(project, "ChapterDrafter", drafterInstructions, true);
    await createOrGetAssistant(project, "LineEditor", lineEditorInstructions, false);
    await createOrGetAssistant(project, "ContinuityEditor", continuityInstructions, true);
    await createOrGetAssistant(project, "BookReviewer", bookReviewerInstructions, true);
    await createOrGetAssistant(project, "CharacterDesigner", characterDesignerInstructions, true);

    setStatus("Assistants initialized.");
    logLine("Assistants initialized.");
  }

  async function runProjectAssistant(project, roleName, userText) {
    if (!project.assistants || !project.assistants[roleName]) {
      logLine("Assistant '" + roleName + "' not found. Initialize first.", true);
      return "";
    }
    setStatus("Running assistant: " + roleName);
    logLine(`Starting assistant task '${roleName}'...`);
    const result = await runAssistantOnce(project.assistants[roleName], userText);
    setStatus("Assistant run complete: " + roleName);
    logLine(`Assistant task '${roleName}' finished.`);
    return result;
  }

  function chapterKey(bookNumber, act, chapter) {
    return `book_${bookNumber}_act_${act}_chapter_${chapter}`;
  }

  function getAvailableBookNumbers(project) {
    const keys = Object.keys(project?.outlines || {});
    const numbers = keys
      .filter((k) => k.startsWith("book_"))
      .map((k) => parseInt(k.replace("book_", ""), 10))
      .filter((n) => !Number.isNaN(n));
    const unique = Array.from(new Set(numbers));
    unique.sort((a, b) => a - b);
    return unique;
  }

  function refreshStoryTargetSelectors(project, keepSelection = false) {
    const books = getAvailableBookNumbers(project);
    const prevBook = keepSelection ? $("#book-select").val() : "";
    const prevAct = keepSelection ? $("#act-select").val() : "";
    const prevChapter = keepSelection ? $("#chapter-select").val() : "";

    const $book = $("#book-select");
    $book.empty();
    $book.append($("<option>").attr("value", "").text("Select book"));
    if (books.length === 0) {
      $book.append($("<option>").attr("value", "1").text("Book 1 (start new)"));
    } else {
      books.forEach((n) => {
        $book.append($("<option>").attr("value", n).text(`Book ${n}`));
      });
      $book.val(prevBook && books.includes(parseInt(prevBook, 10)) ? prevBook : books[0]);
    }

    populateActsForSelectedBook(project, prevAct, prevChapter);
  }

  function populateActsForSelectedBook(project, prevAct = "", prevChapter = "") {
    const selectedBook = $("#book-select").val();
    const $act = $("#act-select");
    const $chapter = $("#chapter-select");
    $act.empty();
    $chapter.empty();
    $act.append($("<option>").attr("value", "").text("Act"));
    $chapter.append($("<option>").attr("value", "").text("Chapter"));
    if (!selectedBook) return;
    const projectObj = getCurrentProject();
    const outline = projectObj?.outlines?.[`book_${selectedBook}`]?.json;
    if (!outline) return;
    const acts = (outline.acts || []).map((a) => String(a.act_number));
    const uniqueActs = Array.from(new Set(acts));
    uniqueActs.forEach((act) => {
      $act.append($("<option>").attr("value", act).text(`Act ${act}`));
    });
    $act.val(uniqueActs.includes(prevAct) ? prevAct : uniqueActs[0]);
    populateChaptersForSelectedAct(projectObj, prevChapter);
  }

  function populateChaptersForSelectedAct(project, prevChapter = "") {
    const selectedBook = $("#book-select").val();
    const selectedAct = $("#act-select").val();
    const $chapter = $("#chapter-select");
    $chapter.empty();
    $chapter.append($("<option>").attr("value", "").text("Chapter"));
    if (!selectedBook || !selectedAct) return;
    const outline = project?.outlines?.[`book_${selectedBook}`]?.json;
    if (!outline) return;
    const actObj = (outline.acts || []).find((a) => String(a.act_number) === String(selectedAct));
    const chapters = (actObj?.chapters || []).map((c) => String(c.chapter_number));
    chapters.forEach((ch) => $chapter.append($("<option>").attr("value", ch).text(`Ch ${ch}`)));
    if (chapters.length) {
      $chapter.val(chapters.includes(prevChapter) ? prevChapter : chapters[0]);
    }
  }

  function getSelectedBookActChapter(project) {
    const bookVal = $("#book-select").val();
    const actVal = $("#act-select").val();
    const chapterVal = $("#chapter-select").val();
    const bookNumber = bookVal ? parseInt(bookVal, 10) : getAvailableBookNumbers(project)[0] || 1;
    return { bookNumber, act: actVal, chapterNum: chapterVal };
  }

  // ==============================
  // WORKFLOWS: CHARACTERS
  // ==============================

  function getActiveCharacterName(project) {
    if (currentCharacterName) return currentCharacterName;
    const names = Object.keys(project?.characters || {});
    return names[0] || null;
  }

  function deriveCharacterNameFromFilename(filename) {
    if (!filename) return null;
    const sheetMatch = filename.match(/^(.*)character\s*sheet/i);
    if (!sheetMatch) return null;
    const base = sheetMatch[1] || "";
    const words = base.replace(/[_-]+/g, " ").replace(/\s+/g, " ").trim();
    return words || null;
  }

  function deriveProfileName(filename) {
    if (!filename) return null;
    const match = filename.match(/^(.*)\s+profile\.(jpg|jpeg|png)$/i);
    if (!match) return null;
    return (match[1] || "").replace(/[_-]+/g, " ").replace(/\s+/g, " ").trim();
  }

  function renderCharacterRoster(project, roster) {
    const $grid = $("#character-grid");
    $grid.empty();

    const sorted = (roster || []).sort((a, b) => a.name.localeCompare(b.name));
    if (!sorted.length) {
      $grid.append($("<div>").addClass("character-grid-empty").text("(no character sheets found yet)"));
    }

    sorted.forEach((entry) => {
      const record = ensureCharacterRecord(project, entry.name);
      const profile = (record?.photos || []).find((p) => p.type === "profile");
      const $card = $("<div>").addClass("character-card").attr("data-name", entry.name);
      if (profile?.dataUrl) {
        $card.append($("<div>").addClass("card-image").css("background-image", `url(${profile.dataUrl})`));
      }
      $card.append($("<div>").addClass("card-overlay"));
      $card.append($("<div>").addClass("card-name").text(entry.name));
      if (currentCharacterName === entry.name) {
        $card.addClass("selected");
      }
      $card.on("click", async () => {
        const projectRef = getCurrentProject();
        if (!projectRef) return;
        await startCharacterCanvasSession(projectRef, entry.name);
      });
      $grid.append($card);
    });

    const $newCard = $("<div>").addClass("character-card new-card");
    $newCard.append($("<div>").addClass("card-add-icon").text("+"));
    $newCard.on("click", () => {
      const projectRef = getCurrentProject();
      if (!projectRef) return;
      showNewCharacterModal(projectRef);
    });
    $grid.append($newCard);

    highlightSelectedCharacterCard();
  }

  async function refreshCharacterRoster(project, silent = false) {
    const docs = await fetchCategoryDocuments(project, CHARACTER_CATEGORY);
    await warmImageCacheForDocs(docs);
    const roster = [];
    for (const doc of docs) {
      const name = deriveCharacterNameFromFilename(doc.baseName || doc.filename);
      if (!name) continue;
      roster.push({ name, filename: doc.filename, driveId: doc.id });
      const record = ensureCharacterRecord(project, name);
      record.sheet = record.sheet || {};
      record.sheet.filename = record.sheet.filename || doc.filename;
      record.sheet.driveId = record.sheet.driveId || doc.id;
      record.sheet.fileId = record.sheet.fileId || doc.mappedFileId || null;
      record.sheet.ext = record.sheet.ext || (doc.baseName.split(".").pop() || "txt").toLowerCase();
      const profileName = deriveProfileName(doc.baseName || doc.filename);
      if (profileName) {
        const profileRecord = ensureCharacterRecord(project, profileName);
        const existingProfile = (profileRecord.photos || []).find((p) => p.type === "profile");
        if (!existingProfile) {
          try {
            const content = await downloadDriveFile(doc.id);
            profileRecord.photos = profileRecord.photos || [];
            profileRecord.photos.unshift({
              driveId: doc.id,
              fileId: doc.mappedFileId || null,
              filename: doc.filename,
              type: "profile",
              dataUrl: content.type === "image" ? content.data : null,
            });
          } catch (e) {
            logLine(`Unable to cache profile photo ${doc.filename}: ${e.message}`, true);
          }
        }
      }
    }

    renderCharacterRoster(project, roster);
    saveProjectsToStorage();
    refreshCharacterSelectUI(project);
    if (!silent) {
      logLine(`Character roster refreshed from file names (${roster.length} found).`);
    }
    return roster;
  }

  function resetCharacterCanvasSession() {
    $("#canvas-chat-log").empty();
    $("#canvas-user-prompt").val("");
    setCanvasText("");
  }

  function hideCharacterCanvas() {
    $("#character-canvas").removeClass("visible");
  }

  async function loadCharacterAssets(project, name) {
    const docs = await fetchCategoryDocuments(project, CHARACTER_CATEGORY);
    const matches = docs.filter((d) => (d.filename || "").toLowerCase().includes(name.toLowerCase()));

    const record = ensureCharacterRecord(project, name);
    for (const match of matches) {
      try {
        if (/character\s*sheet/i.test(match.filename) && !record?.sheet?.text) {
          const content = await downloadDriveFile(match.id);
          if (content.type === "text") {
            const ext = (match.filename.split(".").pop() || "txt").toLowerCase();
            record.sheet = {
              ...(record.sheet || {}),
              text: content.data,
              driveId: match.id,
              fileId: match.mappedFileId || null,
              filename: match.filename,
              ext,
            };
          }
        }
        if (/profile\.(jpg|jpeg|png)$/i.test(match.filename)) {
          const hasProfile = (record?.photos || []).some((p) => p.type === "profile");
          if (!hasProfile) {
            const content = await downloadDriveFile(match.id);
            if (content.type === "image") {
              record.photos = record.photos || [];
              record.photos.unshift({
                driveId: match.id,
                fileId: match.mappedFileId || null,
                filename: match.filename,
                type: "profile",
                dataUrl: content.data,
              });
            }
          }
        }
      } catch (e) {
        logLine(`Unable to load attachment ${match.filename}: ${e.message}`, true);
      }
    }

    try {
      const characterRootId = project.drive.characterFolders?.[name] || (await ensureCharacterFolder(project, name));
      const draftsFolder = await findChildFolder(characterRootId, "drafts");
      if (draftsFolder) {
        const draftFiles = await listDriveFiles(draftsFolder.id);
        record.draftPhotos = record.draftPhotos || [];
        for (const draft of draftFiles) {
          if (draft.mimeType === "application/vnd.google-apps.folder") continue;
          const exists = record.draftPhotos.some((p) => p.driveId === draft.id);
          if (exists) continue;
          try {
            const content = await downloadDriveFile(draft.id);
            record.draftPhotos.push({
              driveId: draft.id,
              filename: draft.name,
              type: /profile/i.test(draft.name) ? "profile-draft" : "gallery-draft",
              dataUrl: content.type === "image" ? content.data : null,
            });
          } catch (inner) {
            logLine(`Unable to load draft ${draft.name}: ${inner.message}`, true);
          }
        }
      }
    } catch (e) {
      logLine(`Unable to load draft assets for ${name}: ${e.message}`, true);
    }

    saveProjectsToStorage();
    return matches;
  }

  function getCanvasText() {
    return $("#canvas-document").text().trim();
  }

  function setCanvasText(text) {
    $("#canvas-document").text(text || "");
  }

  function pushCanvasMessage(role, text) {
    if (!text) return;
    const $log = $("#canvas-chat-log");
    const $msg = $("<div>").addClass("canvas-msg");
    $msg.append($("<div>").addClass("role").text(role.toUpperCase()));
    $msg.append($("<div>").text(text));
    $log.append($msg);
    $log.scrollTop($log[0].scrollHeight);
  }

  function renderCharacterGallery(record) {
    const $track = $("#canvas-gallery-track");
    $track.empty();
    const photos = record?.photos || [];
    if (!photos.length) {
      refreshPhotoTargetSelect(record, true);
      $track.append($("<div>").addClass("canvas-gallery-empty").text("No character images yet."));
      return;
    }
    photos.forEach((photo, idx) => {
      const $thumb = $("<div>").addClass("canvas-thumb");
      if (photo.dataUrl) {
        $thumb.append($("<img>").attr("src", photo.dataUrl));
      } else {
        $thumb.text("No preview available");
      }
      const label = photo.filename || `Photo ${idx + 1}`;
      $thumb.append($("<div>").addClass("thumb-label").text(label));
      $track.append($thumb);
    });
    refreshPhotoTargetSelect(record, true);
  }

  function openCharacterCanvas(name, record, sheetText = null) {
    $("#canvas-character-name").text(name || "None");
    hideDocCanvas();
    hideStoryCanvas();
    $("#character-canvas").addClass("visible");
    if (record?.sheet?.ext) {
      $("#canvas-ext-select").val(record.sheet.ext);
    }
    const textToUse = sheetText || record?.sheet?.text;
    if (textToUse) {
      setCanvasText(textToUse);
    } else if (!getCanvasText()) {
      setCanvasText("Character sheet will appear here for collaborative editing...");
    }
    renderCharacterGallery(record || {});
  }

  async function startCharacterCanvasSession(project, name) {
    if (!name) return;
    const switching = currentCharacterName && currentCharacterName !== name;
    if (!currentCharacterName || switching) {
      resetCharacterCanvasSession();
    }

    setCurrentCharacter(project, name);
    await ensureCharacterSettingsFile(project, name);
    const record = ensureCharacterRecord(project, name);
    const attachments = await loadCharacterAssets(project, name);
    setCharacterMode(characterConversationMode);
    openCharacterCanvas(name, record, record?.sheet?.text || "");
    if (!record?.sheet?.text) {
      setCanvasText("Character sheet will appear here for collaborative editing...");
    }
    if (attachments.length) {
      pushCanvasMessage(
        "system",
        `Loaded ${attachments.length} attachment(s) mentioning ${name}. Canvas is fresh and ready.`
      );
    } else {
      pushCanvasMessage(
        "system",
        "No name-matched attachments found yet. Add character documents or images to deepen context."
      );
    }
  }

  function buildInitialCharacterSheet(name, profileText) {
    return `${name} — Character Sheet\n\nFacts (name, age, race, class, family, origin, skills, etc.):\n${profileText}\n\nOrigin / Backstory:\n- Detail their history and formative events.\n\nRelevance to Story:\n- List current goals, conflicts, and ties to the plot.`;
  }

  async function createCharacterFromModal(project, name, profileText) {
    const record = ensureCharacterRecord(project, name);
    const seedSheet = buildInitialCharacterSheet(name, profileText);
    record.sheet = {
      text: seedSheet,
      ext: "txt",
    };
    setCurrentCharacter(project, name);
    await persistCharacterSheet(project, record, name, seedSheet, "txt");
    await startCharacterCanvasSession(project, name);
  }

  function showNewCharacterModal(project) {
    const $backdrop = $("<div>").addClass("modal-backdrop");
    const $box = $("<div>").addClass("modal-box");
    $box.append($("<h4>").text("New Character"));
    const $nameInput = $("<input>")
      .attr("type", "text")
      .attr("placeholder", "Character name")
      .css("width", "100%");
    const $profileText = $("<textarea>")
      .attr("rows", 6)
      .attr("placeholder", "Profile details to seed the character sheet")
      .css({ width: "100%", marginTop: "6px" });
    const $error = $("<div>").addClass("modal-error").hide();
    const $actions = $("<div>").addClass("modal-actions");
    const $cancel = $("<button>").text("Cancel");
    const $create = $("<button>").text("Create").css("background", "#45a29e");

    $cancel.on("click", () => $backdrop.remove());
    $create.on("click", async () => {
      const name = ($nameInput.val() || "").trim();
      const profile = ($profileText.val() || "").trim();
      if (!name || !profile) {
        $error.text("Name and profile are required.").show();
        return;
      }
      $error.hide();
      $backdrop.remove();
      await createCharacterFromModal(project, name, profile);
    });

    $actions.append($cancel, $create);
    $box.append($nameInput, $profileText, $error, $actions);
    $backdrop.append($box);
    $backdrop.on("click", (e) => {
      if (e.target === $backdrop[0]) {
        $backdrop.remove();
      }
    });
    $("body").append($backdrop);
    $nameInput.focus();
  }

  async function persistCharacterSheet(project, record, name, text, ext) {
    const filename = `${name} Character Sheet.${ext}`;
    const blob = new Blob([text], { type: "text/plain" });
    const file = new File([blob], filename, { type: "text/plain" });

    const parentId = await ensureCharacterFolder(project, name);
    const existingDriveId = record.sheet?.driveId || null;
    const mappedOld = existingDriveId ? project.driveMappings?.["characters"]?.[existingDriveId] : null;
    if (mappedOld) {
      try {
        const vsId = await ensureVectorStore(project, "characters");
        await deleteVectorStoreFile(vsId, mappedOld);
        await deleteOpenAIFile(mappedOld);
      } catch (e) {
        logLine("Failed to remove old sheet file: " + e.message, true);
      }
    }

    const driveEntry = await storeFileWithDriveAndVector(project, "characters", filename, file, { parentId, driveId: existingDriveId });

    record.sheet = {
      driveId: driveEntry.id,
      fileId: project.driveMappings?.["characters"]?.[driveEntry.id] || null,
      filename,
      ext,
      text,
    };
    saveProjectsToStorage();
    refreshCharacterRoster(project, true).catch(() => {});
    logLine(`Saved character sheet for ${name}: ${filename} (Drive ID: ${driveEntry.id})`);
    return driveEntry;
  }

  async function ensureCharacterSettingsFile(project, name) {
    const record = ensureCharacterRecord(project, name);
    if (!record) return null;
    if (record.settings?.driveId) {
      if (!record.settings.json) {
        try {
          const fetched = await downloadDriveFile(record.settings.driveId);
          if (fetched?.type === "text" && fetched.data) {
            record.settings.json = JSON.parse(fetched.data);
          }
        } catch (e) {
          logLine(`Failed to load settings for ${name}: ${e.message}`, true);
        }
      }
      return record.settings;
    }

    const settingsObj = {
      voice_model: "",
      preferences: {},
      updated_at: new Date().toISOString(),
    };
    const blob = new Blob([JSON.stringify(settingsObj, null, 2)], { type: "application/json" });
    const file = new File([blob], `${name} Settings.json`, { type: "application/json" });
    const parentId = await ensureCharacterFolder(project, name);
    const driveEntry = await storeFileWithDriveAndVector(project, CHARACTER_CATEGORY, file.name, file, {
      parentId,
    });

    record.settings = {
      driveId: driveEntry.id,
      fileId: project.driveMappings?.[CHARACTER_CATEGORY]?.[driveEntry.id] || null,
      json: settingsObj,
    };
    saveProjectsToStorage();
    logLine(`Created settings file for ${name} (Drive ID: ${driveEntry.id}).`);
    return record.settings;
  }

  async function downloadCharacterSheetDocx(name, text) {
    const blob = new Blob([text || ""], {
      type: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${name} Character Sheet.docx`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  async function buildStorySourceSummary(project) {
    const categories = ["storyline", "outlines", "relationships"];
    const lines = [];
    for (const cat of categories) {
      const docs = await fetchCategoryDocuments(project, cat);
      const names = docs.map((d) => d.filename);
      lines.push(`${cat}: ${names.length ? names.join(", ") : "(no files found)"}`);
    }
    return lines.join("\n");
  }

  async function scanForOtherCharacters(project) {
    const known = Object.keys(project.characters || {});
    const storySources = await buildStorySourceSummary(project);
    const prompt = `
Use file_search to deeply read the storyline, outlines, and relationships document categories. Identify named characters who are
important to the narrative but do NOT have a character sheet yet.

Current character sheets: ${known.length ? known.join(", ") : "(none)"}

Story sources available (do NOT ask the user for uploads; work with what exists):
${storySources}

Return a concise bullet list with: character name, why they matter, and a suggested "[Name] Character Sheet.txt" title if we
should create one. If a category lacks files, continue using any other context available.
`.trim();

    const text = await runProjectAssistant(project, "LoreKeeper", prompt);
    if (!text) {
      logLine("No scan results returned.", true);
      return;
    }
    logLine("Potential characters to add:\n" + text);
  }

  async function workOnCharacterSheet(project) {
    await refreshCharacterRoster(project, true);
    const name = getActiveCharacterName(project);
    if (!name) {
      alert("Select or create a character first.");
      return;
    }
    await startCharacterCanvasSession(project, name);
  }

  async function sendCharacterCanvasPrompt(project) {
    const name = currentCharacterName || getActiveCharacterName(project);
    if (!name) {
      alert("Select or enter a character first.");
      return;
    }
    const record = ensureCharacterRecord(project, name);
    setCurrentCharacter(project, name);
    openCharacterCanvas(name, record);
    const userPrompt = $("#canvas-user-prompt").val().trim();
    if (!userPrompt) {
      alert("Add a request before sending to the assistant.");
      return;
    }
    pushCanvasMessage("user", userPrompt);
    $("#canvas-user-prompt").val("");
    const currentSheet = getCanvasText() || record.sheet?.text || "";

    if (characterConversationMode === "chat") {
      const storySources = await buildStorySourceSummary(project);
      const promptText = `
You are discussing the character ${name} with the user.
Use file_search to consult character files, storyline, outlines, drafts, and relationships for context.
Do not rewrite the sheet; answer conversationally using the available knowledge.

Current sheet (for reference only):
${currentSheet || "(none yet)"}

Story sources summary:
${storySources}

User questions or discussion points:
${userPrompt}
`.trim();
      const answer = await runProjectAssistant(project, "LoreKeeper", promptText);
      if (!answer) {
        logLine("Assistant returned no discussion response.", true);
        return;
      }
      pushCanvasMessage("assistant", answer);
      return;
    }

    const promptText = `
You are refining the character sheet for ${name}.
Current sheet:
${currentSheet}

User request:
${userPrompt}

Return the full updated sheet text only.
`.trim();
    const newText = await runProjectAssistant(project, "CharacterDesigner", promptText);
    if (!newText) {
      logLine("Assistant returned no updates for the canvas.", true);
      return;
    }
    record.sheet = record.sheet || {};
    record.sheet.text = newText;
    record.sheet.ext = record.sheet.ext || $("#canvas-ext-select").val() || "txt";
    setCanvasText(newText);
    pushCanvasMessage("assistant", newText);
    saveProjectsToStorage();
  }

  async function saveCanvasCharacterSheet(project) {
    const name = currentCharacterName || getActiveCharacterName(project);
    if (!name) {
      alert("Select a character first.");
      return;
    }
    const record = ensureCharacterRecord(project, name);
    const ext = $("#canvas-ext-select").val() || record.sheet?.ext || "txt";
    const text = getCanvasText();
    await persistCharacterSheet(project, record, name, text, ext);
  }

  async function replaceCharacterSheetFromUpload(project, file) {
    const inferredName = deriveCharacterNameFromFilename(file.name);
    const name = inferredName || currentCharacterName || getActiveCharacterName(project);
    if (!name) {
      alert("Name the character before uploading a sheet.");
      return;
    }
    const record = ensureCharacterRecord(project, name);
    setCurrentCharacter(project, name);
    const text = await file.text();
    const ext = (file.name.split(".").pop() || "txt").toLowerCase();
    $("#canvas-ext-select").val(ext);
    setCanvasText(text);
    openCharacterCanvas(name, record);
    await persistCharacterSheet(project, record, name, text, ext);
  }

  function describeCharacterPhotos(record) {
    if (!record?.photos?.length) return "(none yet)";
    return record.photos
      .map((p, idx) => `${idx + 1}. ${p.filename} [${p.type === "profile" ? "profile" : "gallery"}]`)
      .join("\n");
  }

  function refreshPhotoTargetSelect(record, includeDrafts = false) {
    const $target = $("#photo-target-select");
    $target.empty();
    $target.append($("<option>").attr("value", "").text("(choose existing)"));
    (record?.photos || []).forEach((p, idx) => {
      const label = `${idx + 1}: ${p.filename || "photo"} (${p.type || "gallery"})`;
      $target.append($("<option>").attr("value", idx).text(label));
    });
    if (!(record?.photos || []).length) {
      $target.append($("<option>").attr("value", "none").text("(no stored photos)"));
    }
    if (includeDrafts) {
      const drafts = record?.draftPhotos || [];
      if (drafts.length) {
        const $optGroup = $("<optgroup>").attr("label", "Drafts");
        drafts.forEach((p, idx) => {
          const label = `${idx + 1}: ${p.filename || "draft"} (${p.type || "draft"})`;
          $optGroup.append($("<option>").attr("value", `draft-${idx}`).text(label));
        });
        $target.append($optGroup);
      } else {
        $target.append($("<option>").attr("value", "nodrafts").text("(no drafts yet)"));
      }
    }
  }

  async function promoteDraftPhoto(project, characterName, draftEntry) {
    if (!draftEntry) return null;
    const record = ensureCharacterRecord(project, characterName);
    const draftFolderId = await ensureCharacterDraftsFolder(project, characterName);
    const characterFolderId = await ensureCharacterFolder(project, characterName);
    await moveDriveFileToFolder(draftEntry.driveId, characterFolderId, draftFolderId);
    await pushDriveFileToVectorStore(project, "characters", { id: draftEntry.driveId, name: draftEntry.filename });

    const approvedType = draftEntry.type === "profile-draft" ? "profile" : "gallery";
    if (approvedType === "profile") {
      await dropVectorMapping(project, "characters", record.photos.find((p) => p.type === "profile")?.driveId);
      record.photos = (record.photos || []).filter((p) => p.type !== "profile");
    }
    const content = await downloadDriveFile(draftEntry.driveId);
    const newEntry = {
      driveId: draftEntry.driveId,
      fileId: project.driveMappings?.["characters"]?.[draftEntry.driveId] || null,
      filename: draftEntry.filename,
      type: approvedType,
      dataUrl: content.type === "image" ? content.data : draftEntry.dataUrl || null,
    };
    if (approvedType === "profile") {
      record.photos.unshift(newEntry);
    } else {
      record.photos.push(newEntry);
    }
    record.draftPhotos = (record.draftPhotos || []).filter((p) => p.driveId !== draftEntry.driveId);
    saveProjectsToStorage();
    return newEntry;
  }

  async function reviewOrEditCharacterPhotos(project) {
    const name = getActiveCharacterName(project);
    if (!name) {
      alert("Select or enter a character first.");
      return;
    }
    const record = ensureCharacterRecord(project, name);
    record.photos = record.photos || [];
    record.draftPhotos = record.draftPhotos || [];
    setCurrentCharacter(project, name);

    const summary = describeCharacterPhotos(record);
    logLine(`Current photos for ${name}:\n${summary}`);
    refreshPhotoTargetSelect(record, true);

    const mode = $("#photo-action-select").val();
    if (!mode) return;
    const fileInput = document.getElementById("character-photo-input");
    const pickedFile = fileInput && fileInput.files && fileInput.files[0] ? fileInput.files[0] : null;

    async function replaceProfileFromUpload(baseFile) {
      if (!baseFile) {
        alert("Choose a file to upload as the new profile photo.");
        return;
      }
      await dropVectorMapping(project, "characters", record.photos.find((p) => p.type === "profile")?.driveId);
      const ext = (baseFile.name.split(".").pop() || "jpg").toLowerCase();
      const filename = `${name} Profile.${ext}`;
      const parentId = await ensureCharacterFolder(project, name);
      const driveEntry = await storeFileWithDriveAndVector(project, "characters", filename, baseFile, { parentId });
      const dataUrl = await fileToDataUrl(baseFile);
      const entry = {
        driveId: driveEntry.id,
        fileId: project.driveMappings?.["characters"]?.[driveEntry.id] || null,
        filename,
        type: "profile",
        dataUrl,
      };
      record.photos = (record.photos || []).filter((p) => p.type !== "profile");
      record.photos.unshift(entry);
      logLine(`Replaced profile photo for ${name} from upload: ${filename}`);
    }

    async function replaceProfileFromDrive() {
      const rootId = await ensureCharacterFolder(project, name);
      const files = (await listDriveFiles(rootId)).filter(
        (f) => f.mimeType !== "application/vnd.google-apps.folder" && f.mimeType.startsWith("image/")
      );
      if (!files.length) {
        alert("No images found in this character folder on Drive.");
        return;
      }
      const listText = files.map((f, idx) => `${idx + 1}. ${f.name}`).join("\n");
      const choice = prompt(`Pick an image number to use as the profile photo:\n${listText}`);
      const idx = parseInt(choice || "", 10) - 1;
      if (Number.isNaN(idx) || !files[idx]) return;
      const selected = files[idx];
      await dropVectorMapping(project, "characters", record.photos.find((p) => p.type === "profile")?.driveId);
      await pushDriveFileToVectorStore(project, "characters", { id: selected.id, name: selected.name });
      const content = await downloadDriveFile(selected.id);
      const entry = {
        driveId: selected.id,
        fileId: project.driveMappings?.["characters"]?.[selected.id] || null,
        filename: selected.name,
        type: "profile",
        dataUrl: content.type === "image" ? content.data : null,
      };
      record.photos = (record.photos || []).filter((p) => p.type !== "profile");
      record.photos.unshift(entry);
      logLine(`Profile photo for ${name} now points at Drive file ${selected.name}.`);
    }

    async function createProfileDraftFromExisting() {
      const targetPhoto = record.photos.find((p) => p.type === "profile") || null;
      if (!targetPhoto) {
        alert("Add a profile photo first, then you can draft edits from it.");
        return;
      }
      const promptText =
        prompt("Describe how to transform the existing profile into a draft.",
          "Refresh lighting, outfit, and pose while keeping the same face and hair.") ||
        "Refresh lighting, outfit, and pose while keeping the same face and hair.";
      if (!promptText) return;
      const dataUrl = targetPhoto.dataUrl || (await ensureDataUrlFromFileId(targetPhoto.driveId, targetPhoto.filename)).dataUrl;
      if (!dataUrl) {
        alert("Could not load the current profile image from Drive.");
        return;
      }
      const baseFile = dataUrlToFile(dataUrl, targetPhoto.filename || `${name} Profile.png`);
      const editedDataUrl = await editImageWithPrompt(baseFile, promptText);
      const draftFile = dataUrlToFile(editedDataUrl, `Profile Draft - ${name}.png`);
      const driveEntry = await storeDraftImage(project, name, draftFile.name, draftFile);
      const entry = {
        driveId: driveEntry.id,
        filename: draftFile.name,
        type: "profile-draft",
        dataUrl: editedDataUrl,
      };
      record.draftPhotos.push(entry);
      logLine(`Stored profile draft for ${name} in drafts folder: ${draftFile.name}`);
    }

    async function promoteDraftSelection() {
      const targetVal = $("#photo-target-select").val() || "";
      if (!targetVal.startsWith("draft-")) {
        alert("Select a draft from the dropdown before promoting.");
        return;
      }
      const idx = parseInt(targetVal.replace("draft-", ""), 10);
      const draftEntry = record.draftPhotos[idx];
      if (!draftEntry) return;
      await promoteDraftPhoto(project, name, draftEntry);
      logLine(`Promoted draft ${draftEntry.filename} into main library.`);
    }

    async function createGalleryDraft() {
      const promptText =
        prompt(
          "Describe the new gallery image you want. The current profile and approved gallery shots will be used as style references.",
          "Full-body pose in casual outfit, same face and hair as profile."
        ) || "Full-body pose in casual outfit, same face and hair as profile.";
      if (!promptText) return;

      const approvedPhotos = (record.photos || []).filter((p) => p.type === "profile" || p.type === "gallery");
      if (!approvedPhotos.length) {
        alert("Add at least a profile photo first to guide the draft.");
        return;
      }
      const urls = [];
      for (const photo of approvedPhotos) {
        const resolved = photo.dataUrl || (await ensureDataUrlFromFileId(photo.driveId, photo.filename)).dataUrl;
        if (resolved) urls.push(resolved);
      }
      const board = await buildReferenceBoard(urls);
      const baseFile = board?.file || dataUrlToFile(urls[0], `${name} Style Board.png`);
      const editedDataUrl = await editImageWithPrompt(baseFile, promptText);
      const draftFile = dataUrlToFile(editedDataUrl, `${name} Draft Gallery ${Date.now()}.png`);
      const driveEntry = await storeDraftImage(project, name, draftFile.name, draftFile);
      record.draftPhotos.push({
        driveId: driveEntry.id,
        filename: draftFile.name,
        type: "gallery-draft",
        dataUrl: editedDataUrl,
      });
      logLine(`Generated gallery draft for ${name} with style references.`);
    }

    if (mode === "profile-upload") {
      await replaceProfileFromUpload(pickedFile);
    } else if (mode === "profile-drive") {
      await replaceProfileFromDrive();
    } else if (mode === "profile-edit-draft") {
      await createProfileDraftFromExisting();
    } else if (mode === "promote-draft") {
      await promoteDraftSelection();
    } else if (mode === "gallery-draft") {
      await createGalleryDraft();
    }

    saveProjectsToStorage();
    if (fileInput) fileInput.value = "";
    if ($("#character-canvas").hasClass("visible") && currentCharacterName === name) {
      renderCharacterGallery(record);
    }
    refreshPhotoTargetSelect(record, true);
  }

  // ==============================
  // STORY ARC CANVAS
  // ==============================

  function getStoryArcRecord(project) {
    ensureProjectStructure(project);
    project.storyArc = project.storyArc || { filename: "story_arc.txt" };
    project.storyArc.filename = project.storyArc.filename || "story_arc.txt";
    return project.storyArc;
  }

  function setStoryCanvasMode(mode) {
    storyConversationMode = mode === "qa" ? "qa" : "edit";
    $("#story-mode-toggle button").removeClass("active");
    $(`#story-mode-toggle button[data-mode='${storyConversationMode}']`).addClass("active");
    const placeholder =
      storyConversationMode === "edit"
        ? "Ask for revisions to the story arc..."
        : "Ask questions about the arc and get answers from context...";
    $("#story-user-prompt").attr("placeholder", placeholder);
  }

  function setStoryCanvasText(text) {
    $("#story-canvas-document").text(text || "");
  }

  function getStoryCanvasText() {
    return ($("#story-canvas-document").text() || "").trim();
  }

  function pushStoryMessage(role, text) {
    const $entry = $("<div>").addClass("chat-message").addClass(role);
    $entry.append($("<div>").addClass("sender").text(role === "user" ? "You" : role === "assistant" ? "Assistant" : "System"));
    $entry.append($("<div>").addClass("content").text(text));
    $("#story-chat-log").append($entry);
    $("#story-chat-log").scrollTop($("#story-chat-log")[0].scrollHeight);
  }

  async function loadStoryArc(project, forceReload = false) {
    const record = getStoryArcRecord(project);
    if (forceReload) {
      record.text = null;
    }
    if (record.driveId && !record.text) {
      try {
        const dl = await downloadDriveFile(record.driveId);
        if (dl?.type === "text") {
          record.text = dl.data;
        }
      } catch (e) {
        logLine("Failed to load story arc from Drive: " + e.message, true);
      }
    }
    return record.text || "";
  }

  async function saveStoryArcText(project, text) {
    const record = getStoryArcRecord(project);
    const filename = record.filename || "story_arc.txt";
    const blob = new Blob([text || ""], { type: "text/plain" });
    const file = new File([blob], filename, { type: "text/plain" });
    const parentId = await ensureCategoryFolder(project, "storyline");
    const driveEntry = await storeFileWithDriveAndVector(project, "storyline", filename, file, {
      parentId,
      driveId: record.driveId,
    });
    record.driveId = driveEntry.id;
    record.fileId = project.driveMappings?.["storyline"]?.[driveEntry.id] || null;
    record.text = text;
    project.storyArc = record;
    saveProjectsToStorage();
    currentStoryArc = record;
    return record;
  }

  async function openStoryCanvas(project, preferReload = false) {
    if (!project) return;
    hideDocCanvas();
    hideCharacterCanvas();
    $("#story-canvas").addClass("visible");
    setStoryCanvasMode(storyConversationMode);
    const text = preferReload ? await loadStoryArc(project, true) : await loadStoryArc(project);
    const fallback =
      "Story arc canvas is empty. Generate or paste an arc here. Keep it plain text with a TLDR Story Arc section at the bottom.";
    setStoryCanvasText(text || fallback);
    currentStoryArc = getStoryArcRecord(project);
    if (!text) {
      pushStoryMessage("system", "No saved story arc found yet. Create one to begin.");
    }
  }

  async function sendStoryCanvasPrompt(project) {
    if (!project) {
      alert("Select a project first.");
      return;
    }
    const userPrompt = $("#story-user-prompt").val().trim();
    if (!userPrompt) {
      alert("Enter a request or question first.");
      return;
    }
    $("#story-user-prompt").val("");
    const currentText = getStoryCanvasText();
    pushStoryMessage("user", userPrompt);

    if (storyConversationMode === "qa") {
      const storySources = await buildStorySourceSummary(project);
      const promptText = `You are answering questions about the project's story arc. Use file_search to consult storyline, outlines, and relationships. Respond in plain text (no markdown).\n\nCurrent story arc text (plain text):\n${currentText || "(none yet)"}\n\nStory sources:\n${storySources}\n\nQuestions:\n${userPrompt}`;
      const answer = await runProjectAssistant(project, "LoreKeeper", promptText);
      if (answer) {
        pushStoryMessage("assistant", answer);
      }
      return;
    }

    const editPrompt = `We maintain a plain-text story arc document. It must end with a "TLDR Story Arc" section that lists each book and its chapters in nested, concise outline form with short, decision-focused plot points, emotional hooks, and key facts. Keep everything plain text with indentation (no markdown symbols).\n\nCurrent story arc text:\n${currentText || "(none yet)"}\n\nUser request:\n${userPrompt}\n\nReturn the fully updated story arc text, keeping the TLDR Story Arc section at the bottom.`;
    const updated = await runProjectAssistant(project, "SeriesArchitect", editPrompt);
    if (!updated) {
      logLine("Assistant returned no updated story arc.", true);
      return;
    }
    setStoryCanvasText(updated);
    await saveStoryArcText(project, updated);
    pushStoryMessage("assistant", "Story arc updated and saved.");
  }

  async function refreshStoryArcFromDrive(project) {
    const text = await loadStoryArc(project, true);
    setStoryCanvasText(text);
    pushStoryMessage("system", "Reloaded story arc from Drive.");
  }

  // ==============================
  // WORKFLOWS: OUTLINES & CHAPTERS
  // ==============================

  async function buildTrilogyOutline(project) {
    const prompt = `
Using all available lore, campaign notes, and outlines in this project:
- Propose a 3-book trilogy structure.
- Follow your system instructions.

Add at the end a plain-text "TLDR Story Arc" section that lists each book and its chapters in nested order. Each entry should be a short, decision-focused plot beat with the key emotional hook. Keep the entire response plain text (no markdown symbols).

Structure your answer like:

1. Trilogy Overview
2. Book 1 - [Working Title]
3. Book 2 - [Working Title]
4. Book 3 - [Working Title]
`.trim();

    const text = await runProjectAssistant(project, "SeriesArchitect", prompt);
    if (!text) {
      logLine("No trilogy outline returned.", true);
      return;
    }

    project.outlines = project.outlines || {};
    project.outlines["trilogy_markdown"] = { text: text };
    const arcRecord = await saveStoryArcText(project, text);
    saveProjectsToStorage();

    logLine("Trilogy outline generated and stored as the story arc.");
    const blob = new Blob([text], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const $link = $("<a>")
      .addClass("download-link")
      .attr("href", url)
      .attr("download", arcRecord?.filename || "story_arc.txt")
      .text(`Download ${arcRecord?.filename || "story_arc.txt"}`);
    logLine("Click to download trilogy outline:");
    logLink(`Download ${arcRecord?.filename || "story_arc.txt"}`, url, arcRecord?.filename || "story_arc.txt");
  }

  async function buildBookOutline(project) {
    const { bookNumber } = getSelectedBookActChapter(project);

    const promptText = `
Using the trilogy outline (if available) and all project lore:
- Create a structured JSON outline for Book ${bookNumber} exactly matching the schema in your system instructions.
`.trim();

    const raw = await runProjectAssistant(project, "BookOutliner", promptText);
    if (!raw) {
      logLine("No outline returned for Book " + bookNumber, true);
      return;
    }

    let outlineJson;
    try {
      outlineJson = JSON.parse(raw);
    } catch (e) {
      logLine("Invalid JSON outline returned: " + e, true);
      logLine("Raw outline (first 1000 chars): " + raw.slice(0, 1000), true);
      return;
    }

    project.outlines = project.outlines || {};
    const key = "book_" + bookNumber;
    const old = project.outlines[key];
    const parentId = await ensureCategoryFolder(project, "outlines");
    const mappedOld = old?.driveId ? project.driveMappings?.["outlines"]?.[old.driveId] : old?.fileId;
    if (mappedOld) {
      try {
        const vsId = await ensureVectorStore(project, "outlines");
        await deleteVectorStoreFile(vsId, mappedOld);
        await deleteOpenAIFile(mappedOld);
      } catch (e) {
        logLine("Failed to delete old outline file: " + e, true);
      }
    }

    const jsonBlob = new Blob([JSON.stringify(outlineJson, null, 2)], { type: "application/json" });
    const jsonFile = new File([jsonBlob], `book_${bookNumber}_outline.json`, { type: "application/json" });
    const driveEntry = await storeFileWithDriveAndVector(project, "outlines", jsonFile.name, jsonFile, {
      parentId,
      driveId: old?.driveId,
    });

    project.outlines[key] = {
      driveId: driveEntry.id,
      fileId: project.driveMappings?.["outlines"]?.[driveEntry.id] || null,
      json: outlineJson,
    };
    saveProjectsToStorage();
    refreshStoryTargetSelectors(project, true);
    logLine("Book " + bookNumber + " outline stored to Drive and vector store.");

    const dlBlob = new Blob([JSON.stringify(outlineJson, null, 2)], { type: "application/json" });
    const dlUrl = URL.createObjectURL(dlBlob);
    const $link = $("<a>")
      .addClass("download-link")
      .attr("href", dlUrl)
      .attr("download", `book_${bookNumber}_outline.json`)
      .text(`Download book_${bookNumber}_outline.json`);
    logLine("Click to download JSON outline:");
    logLink(`Download book_${bookNumber}_outline.json`, dlUrl, `book_${bookNumber}_outline.json`);
  }

  async function draftChapter(project) {
    const { bookNumber, act, chapterNum } = getSelectedBookActChapter(project);
    if (!bookNumber) {
      alert("Select a book in Story Targets first.");
      return;
    }
    if (!act || !chapterNum) {
      alert("Choose an act and chapter in Story Targets before drafting.");
      return;
    }

    project.outlines = project.outlines || {};
    const outlineEntry = project.outlines["book_" + bookNumber];
    if (!outlineEntry || !outlineEntry.json) {
      logLine("No JSON outline found for Book " + bookNumber + ". Build it first.", true);
      return;
    }
    const outline = outlineEntry.json;
    const acts = outline.acts || [];
    let chapterStruct = null;
    for (const actObj of acts) {
      if (String(actObj.act_number) === String(act)) {
        for (const ch of actObj.chapters || []) {
          if (String(ch.chapter_number) === String(chapterNum)) {
            chapterStruct = ch;
            break;
          }
        }
      }
      if (chapterStruct) break;
    }
    if (!chapterStruct) {
      logLine("Chapter not found in JSON outline.", true);
      return;
    }

    const pov = chapterStruct.pov || "Unknown";
    const title = chapterStruct.chapter_title || ("Chapter " + chapterNum);
    const targetWords = chapterStruct.target_words || 3000;
    const summary = chapterStruct.summary || "";
    const emotionalGoal = chapterStruct.emotional_goal || "";
    const beatsList = chapterStruct.scene_beats || [];
    const beatsText = beatsList.map((b) => "- " + b).join("\n");

    const promptText = `
Draft the following chapter for this novel.

Book: ${bookNumber}
Act: ${act}
Chapter: ${chapterNum}
Title: ${title}
POV: ${pov}
Target words: ${targetWords}

Chapter Summary:
${summary}

Emotional Goal:
${emotionalGoal}

Scene Beats:
${beatsText}

Please write the full chapter, following your system-level drafting rules.
`.trim();

    const chapterText = await runProjectAssistant(project, "ChapterDrafter", promptText);
    if (!chapterText) {
      logLine("No chapter text returned.", true);
      return;
    }

    project.chapters = project.chapters || {};
    const key = chapterKey(bookNumber, act, chapterNum);
    const old = project.chapters[key];

    const draftsParent = await ensureCategoryFolder(project, "drafts");
    await ensureVectorStore(project, "drafts");
    const existingDriveId = old?.driveId;
    const mappedOld = existingDriveId ? project.driveMappings?.["drafts"]?.[existingDriveId] : old?.fileId;
    if (mappedOld) {
      try {
        const vsId = await ensureVectorStore(project, "drafts");
        await deleteVectorStoreFile(vsId, mappedOld);
        await deleteOpenAIFile(mappedOld);
      } catch (e) {
        logLine("Failed to delete old chapter file: " + e, true);
      }
    }
    const textBlob = new Blob([chapterText], { type: "text/plain" });
    const textFile = new File(
      [textBlob],
      `book${bookNumber}_act${act}_chapter${chapterNum}_draft.txt`,
      { type: "text/plain" }
    );
    const driveEntry = await storeFileWithDriveAndVector(project, "drafts", textFile.name, textFile, {
      parentId: draftsParent,
      driveId: existingDriveId,
    });

    project.chapters[key] = {
      driveId: driveEntry.id,
      fileId: project.driveMappings?.["drafts"]?.[driveEntry.id] || null,
      text: chapterText,
    };
    saveProjectsToStorage();

    logLine(`Drafted chapter: Book ${bookNumber}, Act ${act}, Chapter ${chapterNum}. DriveId: ${driveEntry.id}`);

    const dlBlob = new Blob([chapterText], { type: "text/plain" });
    const dlUrl = URL.createObjectURL(dlBlob);
    const $link = $("<a>")
      .addClass("download-link")
      .attr("href", dlUrl)
      .attr("download", `book${bookNumber}_act${act}_chapter${chapterNum}_draft.txt`)
      .text(`Download chapter draft (Book ${bookNumber} Act ${act} Ch ${chapterNum})`);
    logLine("Click to download draft:");
    logLink(
      `Download chapter draft (Book ${bookNumber} Act ${act} Ch ${chapterNum})`,
      dlUrl,
      `book${bookNumber}_act${act}_chapter${chapterNum}_draft.txt`
    );
  }

  async function draftWholeBook(project, bookNumber) {
    project.outlines = project.outlines || {};
    const outlineEntry = project.outlines["book_" + bookNumber];
    if (!outlineEntry || !outlineEntry.json) {
      logLine(`No JSON outline found for Book ${bookNumber}. Build it first.`, true);
      return;
    }
    const outline = outlineEntry.json;
    const acts = outline.acts || [];
    if (!acts.length) {
      logLine("Outline has no acts.", true);
      return;
    }

    logLine(`Drafting entire Book ${bookNumber}...`);

    const sortedActs = [...acts].sort((a, b) => (a.act_number || 0) - (b.act_number || 0));
    project.chapters = project.chapters || {};
    const vsId = await ensureVectorStore(project, "drafts");

    for (const actObj of sortedActs) {
      const actNum = actObj.act_number;
      const chapters = actObj.chapters || [];
      const sortedChapters = [...chapters].sort((a, b) => (a.chapter_number || 0) - (b.chapter_number || 0));

      for (const ch of sortedChapters) {
        const chNum = ch.chapter_number;
        const pov = ch.pov || "Unknown";
        const title = ch.chapter_title || `Chapter ${chNum}`;
        const targetWords = ch.target_words || 3000;
        const summary = ch.summary || "";
        const emotionalGoal = ch.emotional_goal || "";
        const beatsList = ch.scene_beats || [];
        const beatsText = beatsList.map((b) => "- " + b).join("\n");

        logLine(`--- Drafting Book ${bookNumber} | Act ${actNum} | Chapter ${chNum} ---`);

        const promptText = `
Draft the following chapter for this novel.

Book: ${bookNumber}
Act: ${actNum}
Chapter: ${chNum}
Title: ${title}
POV: ${pov}
Target words: ${targetWords}

Chapter Summary:
${summary}

Emotional Goal:
${emotionalGoal}

Scene Beats:
${beatsText}

Please write the full chapter now, following your system-level drafting rules.
`.trim();

        try {
          const chapterText = await runProjectAssistant(project, "ChapterDrafter", promptText);
          if (!chapterText) {
            logLine(`No text returned for Book ${bookNumber}, Act ${actNum}, Chapter ${chNum}.`, true);
            continue;
          }

          const key = chapterKey(bookNumber, actNum, chNum);
          const old = project.chapters[key];
          const existingDriveId = old?.driveId;
          const mappedOld = existingDriveId ? project.driveMappings?.["drafts"]?.[existingDriveId] : old?.fileId;
          if (mappedOld) {
            try {
              const vsId = await ensureVectorStore(project, "drafts");
              await deleteVectorStoreFile(vsId, mappedOld);
              await deleteOpenAIFile(mappedOld);
            } catch (e) {
              logLine("Failed to delete old chapter file: " + e, true);
            }
          }

          const textBlob = new Blob([chapterText], { type: "text/plain" });
          const fileName = `book${bookNumber}_act${actNum}_chapter${chNum}_draft.txt`;
          const textFile = new File([textBlob], fileName, { type: "text/plain" });
          const driveEntry = await storeFileWithDriveAndVector(project, "drafts", fileName, textFile, {
            parentId: draftsParent,
            driveId: existingDriveId,
          });

          project.chapters[key] = {
            driveId: driveEntry.id,
            fileId: project.driveMappings?.["drafts"]?.[driveEntry.id] || null,
            text: chapterText,
          };
          saveProjectsToStorage();

          logLine(`Drafted Book ${bookNumber}, Act ${actNum}, Chapter ${chNum}. DriveId: ${driveEntry.id}`);
        } catch (e) {
          logLine(`Error drafting Book ${bookNumber}, Act ${actNum}, Chapter ${chNum}: ` + e.message, true);
        }
      }
    }

    logLine(`Finished drafting entire Book ${bookNumber}.`);
  }

  async function editChapter(project) {
    const { bookNumber, act, chapterNum } = getSelectedBookActChapter(project);
    if (!bookNumber || !act || !chapterNum) {
      alert("Select book, act, and chapter in Story Targets before editing.");
      return;
    }

    project.chapters = project.chapters || {};
    const key = chapterKey(bookNumber, act, chapterNum);
    let entry = project.chapters[key];

    let chapterText;
    if (entry && entry.text) {
      chapterText = entry.text;
    } else {
      chapterText = prompt("No stored chapter text for this key. Paste the chapter text to edit:", "");
      if (!chapterText) {
        logLine("No chapter text provided.", true);
        return;
      }
    }

    logLine(`Running line edit for Book ${bookNumber}, Act ${act}, Chapter ${chapterNum}...`);

    const lineEditPrompt = `
Please line-edit the following chapter:
- Improve clarity, pacing, rhythm, and dialogue.
- Preserve all events, POV, and emotional beats.
- Keep the same tense and overall voice.
Output ONLY the edited chapter text.

`.trim();

    const lineEdited = await runProjectAssistant(
      project,
      "LineEditor",
      lineEditPrompt + "\n\n" + chapterText
    );
    if (!lineEdited) {
      logLine("Line editor returned no text.", true);
      return;
    }

    logLine("Running continuity pass...");

    const contPrompt = `
Check this chapter against project lore and prior material using file_search.

1) List continuity issues and how to fix them.
2) Then output a corrected version of the chapter.

Format:

ISSUES:
1. ...

CORRECTED CHAPTER:
[chapter text]
`.trim();

    const contResult = await runProjectAssistant(
      project,
      "ContinuityEditor",
      contPrompt + "\n\n" + lineEdited
    );
    if (!contResult) {
      logLine("Continuity editor returned no text.", true);
      return;
    }

    const finalText = contResult;
    project.chapters[key] = project.chapters[key] || {};
    project.chapters[key].text = finalText;

    const parentId = await ensureCategoryFolder(project, "drafts");
    const existingDriveId = project.chapters[key].driveId;
    const mappedOld = existingDriveId ? project.driveMappings?.["drafts"]?.[existingDriveId] : project.chapters[key].fileId;
    if (mappedOld) {
      try {
        const vsId = await ensureVectorStore(project, "drafts");
        await deleteVectorStoreFile(vsId, mappedOld);
        await deleteOpenAIFile(mappedOld);
      } catch (e) {
        logLine("Failed to delete old file: " + e, true);
      }
    }

    const textBlob = new Blob([finalText], { type: "text/plain" });
    const fileName = `book${bookNumber}_act${act}_chapter${chapterNum}_edited_with_continuity.txt`;
    const textFile = new File([textBlob], fileName, { type: "text/plain" });
    const driveEntry = await storeFileWithDriveAndVector(project, "drafts", fileName, textFile, {
      parentId,
      driveId: existingDriveId,
    });

    project.chapters[key].driveId = driveEntry.id;
    project.chapters[key].fileId = project.driveMappings?.["drafts"]?.[driveEntry.id] || null;
    saveProjectsToStorage();

    logLine(`Edited chapter stored. Drive Id: ${driveEntry.id}`);

    const dlUrl = URL.createObjectURL(textBlob);
    const $link = $("<a>")
      .addClass("download-link")
      .attr("href", dlUrl)
      .attr("download", fileName)
      .text(`Download edited chapter (Book ${bookNumber} Act ${act} Ch ${chapterNum})`);
    logLine("Click to download edited chapter:");
    logLink(
      `Download edited chapter (Book ${bookNumber} Act ${act} Ch ${chapterNum})`,
      dlUrl,
      fileName
    );
  }

  async function reviewWholeBook(project) {
    const { bookNumber } = getSelectedBookActChapter(project);
    if (!bookNumber) {
      alert("Select a book in Story Targets first.");
      return;
    }

    project.chapters = project.chapters || {};
    const keys = Object.keys(project.chapters).filter((k) =>
      k.startsWith(`book_${bookNumber}_`)
    );
    if (!keys.length) {
      logLine("No chapters recorded for Book " + bookNumber, true);
      return;
    }
    keys.sort();

    const combinedParts = [];
    for (const key of keys) {
      const ch = project.chapters[key];
      if (!ch.text) {
        logLine(`Chapter ${key} has no stored text, skipping.`, true);
        continue;
      }
      combinedParts.push(`\n\n===== ${key} =====\n\n${ch.text}\n`);
    }
    if (!combinedParts.length) {
      logLine("No chapter text available for that book.", true);
      return;
    }

    const combinedText = combinedParts.join("");
    const promptText = `
Below is a collection of chapters from this novel project.

Please:
- Summarize the current book as written.
- Identify strengths and weaknesses in plot, character arcs, pacing, and tone.
- Highlight any apparent inconsistencies or confusing elements.
- Suggest concrete restructuring or revisions to improve unity and focus.
`.trim();

    const reviewText = await runProjectAssistant(
      project,
      "BookReviewer",
      promptText + "\n\n" + combinedText
    );
    if (!reviewText) {
      logLine("BookReviewer returned no text.", true);
      return;
    }

    const blob = new Blob([reviewText], { type: "text/plain" });
    const fileName = `book_${bookNumber}_level_review.txt`;
    const url = URL.createObjectURL(blob);

    logLine("Book-level review generated for Book " + bookNumber);
    logLink(`Download ${fileName}`, url, fileName);
  }

  async function ttsForChapter(project) {
    const { bookNumber, act, chapterNum } = getSelectedBookActChapter(project);
    if (!bookNumber || !act || !chapterNum) {
      alert("Pick book, act, and chapter in Story Targets first.");
      return;
    }

    project.chapters = project.chapters || {};
    const key = chapterKey(bookNumber, act, chapterNum);
    const entry = project.chapters[key];
    let text;
    if (entry && entry.text) {
      text = entry.text;
    } else {
      text = prompt("No stored text found. Paste the chapter text to read aloud:", "");
      if (!text) {
        logLine("No text provided.", true);
        return;
      }
    }

    const maxChars = 3500;
    let narratorText = text;
    if (text.length > maxChars) {
      narratorText = text.slice(0, maxChars);
      logLine("Chapter text is long; truncating to " + maxChars + " characters for narrator TTS.");
    }

    logLine("Generating narrator TTS (voice: alloy)...");
    const narratorBlob = await openaiAudio("/audio/speech", {
      model: "tts-1",
      voice: "alloy",
      input: narratorText,
      response_format: "mp3",
    });
    const narratorUrl = URL.createObjectURL(narratorBlob);
    const narratorFileName = `book${bookNumber}_act${act}_chapter${chapterNum}_narrator.mp3`;
    logLine("Narrator audio ready:");
    logLink("Download narrator audio", narratorUrl, narratorFileName);

    if (confirm("Generate a MALE voice clip for some lines?")) {
      const maleSnippet = prompt("Paste the text for the MALE voice:", "");
      if (maleSnippet) {
        logLine("Generating male TTS (voice: onyx)...");
        const maleBlob = await openaiAudio("/audio/speech", {
          model: "tts-1",
          voice: "onyx",
          input: maleSnippet.slice(0, maxChars),
          response_format: "mp3",
        });
        const maleUrl = URL.createObjectURL(maleBlob);
        const maleFileName = `book${bookNumber}_act${act}_chapter${chapterNum}_male.mp3`;
        logLine("Male voice audio ready:");
        logLink("Download male voice audio", maleUrl, maleFileName);
      }
    }

    if (confirm("Generate a FEMALE voice clip for some lines?")) {
      const femaleSnippet = prompt("Paste the text for the FEMALE voice:", "");
      if (femaleSnippet) {
        logLine("Generating female TTS (voice: nova)...");
        const femaleBlob = await openaiAudio("/audio/speech", {
          model: "tts-1",
          voice: "nova",
          input: femaleSnippet.slice(0, maxChars),
          response_format: "mp3",
        });
        const femaleUrl = URL.createObjectURL(femaleBlob);
        const femaleFileName = `book${bookNumber}_act${act}_chapter${chapterNum}_female.mp3`;
        logLine("Female voice audio ready:");
        logLink("Download female voice audio", femaleUrl, femaleFileName);
      }
    }

    logLine("TTS generation complete.");
  }

  async function soraStub() {
    logLine("Sora / video generation is not implemented in this HTML client yet.");
    logLine("You can add a call to the video endpoint once your access is ready.");
  }

  // ==============================
  // DOC / VECTOR STORE UI ACTIONS
  // ==============================

  async function pushDriveFileToVectorStore(project, category, driveFile) {
    const content = await downloadDriveFile(driveFile.id);
    const vsId = await ensureVectorStore(project, category);
    const fileObj = new File([content.blob], driveFile.name, { type: content.blob.type || "application/octet-stream" });
    const uploadRes = await uploadFileToOpenAI(fileObj);
    await attachFileToVectorStore(vsId, uploadRes.id);
    rememberDriveMapping(project, category, driveFile.id, uploadRes.id);
    return uploadRes.id;
  }

  async function storeFileWithDriveAndVector(project, category, filename, blob, options = {}) {
    const parentId = options.parentId || (await ensureCategoryFolder(project, category));
    const driveEntry = await uploadBlobToDrive(filename, blob, parentId, options.driveId || null);
    await pushDriveFileToVectorStore(project, category, driveEntry);
    return driveEntry;
  }

  async function storeDraftImage(project, characterName, filename, blob) {
    const parentId = await ensureCharacterDraftsFolder(project, characterName);
    return await uploadBlobToDrive(filename, blob, parentId, null);
  }

  async function dropVectorMapping(project, category, driveId) {
    const mapped = project.driveMappings?.[category]?.[driveId];
    if (!mapped) return;
    try {
      const vsId = await ensureVectorStore(project, category);
      await deleteVectorStoreFile(vsId, mapped);
      await deleteOpenAIFile(mapped);
    } catch (e) {
      logLine(`Unable to drop vector mapping for ${driveId}: ${e.message}`, true);
    }
    forgetDriveMapping(project, category, driveId);
  }

  async function resyncCategoryFromDrive(project, category) {
    const vsId = await ensureVectorStore(project, category);
    try {
      const existing = await listVectorStoreFiles(vsId);
      for (const entry of existing.data || []) {
        try {
          await deleteVectorStoreFile(vsId, entry.id);
          await deleteOpenAIFile(entry.id);
        } catch (e) {
          logLine(`Unable to remove stale vector store file ${entry.id}: ${e.message}`, true);
        }
      }
    } catch (e) {
      logLine(`Unable to flush vector store for ${category}: ${e.message}`, true);
    }

    project.driveMappings = project.driveMappings || {};
    project.driveMappings[category] = {};
    const docs = await fetchCategoryDocuments(project, category);
    for (const doc of docs) {
      await pushDriveFileToVectorStore(project, category, { id: doc.id, name: doc.baseName });
    }
    saveProjectsToStorage();
    await renderDocExplorer(project, category);
    logLine(`Resynced ${category} from Drive into vector store.`);
  }

  async function reconcileVectorStoreCategory(project, category) {
    if (category === "drafts") return; // drafts stay out of vector stores
    const vsId = await ensureVectorStore(project, category);

    let vsEntries = [];
    try {
      const list = await listVectorStoreFiles(vsId);
      vsEntries = list.data || [];
    } catch (e) {
      logLine(`Unable to list vector store files for ${category}: ${e.message}`, true);
      return;
    }

    const mapped = project.driveMappings?.[category] || {};
    const mappedValues = new Set(Object.values(mapped || {}));
    const driveDocs = (await fetchCategoryDocuments(project, category, { draftsOnly: false })).filter((d) => !d.isDraft);
    const driveIds = new Set(driveDocs.map((d) => d.id));
    const vectorIds = new Set(vsEntries.map((f) => f.id));

    for (const entry of vsEntries) {
      if (!mappedValues.has(entry.id)) {
        try {
          await deleteVectorStoreFile(vsId, entry.id);
          await deleteOpenAIFile(entry.id);
          logLine(`Removed stale vector store file for ${category}: ${entry.id}`);
        } catch (e) {
          logLine(`Unable to prune vector store file ${entry.id}: ${e.message}`, true);
        }
      }
    }

    Object.keys(mapped).forEach((driveId) => {
      if (!driveIds.has(driveId)) {
        forgetDriveMapping(project, category, driveId);
      }
    });

    for (const doc of driveDocs) {
      const mappedId = mapped[doc.id];
      const upToDate = mappedId && vectorIds.has(mappedId);
      if (upToDate) continue;
      try {
        await pushDriveFileToVectorStore(project, category, { id: doc.id, name: doc.baseName });
        logLine(`Synced ${doc.filename} from Drive into ${category} vector store.`);
      } catch (e) {
        logLine(`Unable to sync ${doc.filename} into vector store: ${e.message}`, true);
      }
    }

    saveProjectsToStorage();
  }

  async function alignVectorStoresToDrive(project) {
    beginLongLoading();
    setStatus("Aligning vector stores with Google Drive...");
    try {
      for (const category of CATEGORY_FOLDERS) {
        try {
          await reconcileVectorStoreCategory(project, category);
        } catch (e) {
          logLine(`Vector alignment for ${category} failed: ${e.message}`, true);
        }
      }
      setStatus("Drive and vector stores aligned.");
    } finally {
      endLongLoading();
    }
  }

  async function uploadDocsForCategory(project) {
    const category = $("#doc-category-select").val();
    const files = $("#file-upload-input")[0].files;
    if (!files || files.length === 0) {
      logLine("No files selected for upload.", true);
      return;
    }
    await uploadDocumentsToCategory(project, category, files);
    await renderDocExplorer(project, category);
    $("#file-upload-input").val("");
  }

  async function uploadDocumentsToCategory(project, category, fileList) {
    let parentId = null;
    if (category === CHARACTER_CATEGORY && currentCharacterName) {
      parentId = await ensureCharacterFolder(project, currentCharacterName);
    }
    for (const file of fileList) {
      try {
        logLine(`Uploading file "${file.name}" for category "${category}"...`);
        await storeFileWithDriveAndVector(project, category, file.name, file, { parentId });
      } catch (e) {
        logLine("Error uploading file: " + e.message, true);
      }
    }
  }

  async function listFilesInCategory(project) {
    const category = $("#doc-category-select").val();
    const files = await fetchCategoryDocuments(project, category);
    if (!files.length) {
      logLine("No files found in Drive for this category.");
      return;
    }
    files.forEach((item) => {
      logLine(`  driveId=${item.id} | filename=${item.filename} | mimeType=${item.mimeType}`);
    });
  }

  async function loadCategoryFileOptions(project, category) {
    const $sel = $("#category-file-select");
    $sel.empty();
    const parentId = await ensureCategoryFolder(project, category);
    const files = await listDriveFiles(parentId);
    if (!files.length) {
      $sel.append($("<option>").val("").text("(no files)"));
      return [];
    }
    files.forEach((item) => {
      $sel.append($("<option>").val(item.id).text(`${item.name}`));
    });
    return files.map((f) => ({ id: f.id, filename: f.name }));
  }

  async function removeFileFromCategory(project) {
    const category = $("#doc-category-select").val();
    const files = await loadCategoryFileOptions(project, category);
    if (!files.length) {
      logLine("No files available to remove.", true);
      return;
    }
    const choice = await showSelectModal(
      `Remove file from ${category}`,
      files.map((f) => ({ value: f.id, label: f.filename }))
    );
    if (!choice) return;
    const driveId = choice;
    try {
      const mapped = project.driveMappings?.[category]?.[driveId];
      if (mapped) {
        try {
          await deleteVectorStoreFile(project.vectorStores[category], mapped);
          await deleteOpenAIFile(mapped);
        } catch (e) {
          logLine("Failed to remove OpenAI mapping: " + e.message, true);
        }
      }
      await deleteDriveFile(driveId);
      forgetDriveMapping(project, category, driveId);
      logLine("Removed file from Drive and vector store.");
      await renderDocExplorer(project, category);
    } catch (e) {
      logLine("Error removing file: " + e.message, true);
    }
  }

  function showDocCanvas(project, category) {
    if (!project) return;
    const cat = category || $("#doc-category-select").val() || "characters";
    if (cat !== CHARACTER_CATEGORY) {
      docExplorerShowDrafts = false;
    }
    $("#doc-drafts-toggle")
      .text(docExplorerShowDrafts ? "Show Approved" : "Show Drafts")
      .prop("disabled", cat !== CHARACTER_CATEGORY)
      .toggle(cat === CHARACTER_CATEGORY);
    $("#doc-canvas-category").text(cat);
    $("#doc-canvas").addClass("visible");
    hideStoryCanvas();
    hideCharacterCanvas();
    renderDocExplorer(project, cat).catch((e) => logLine("Error rendering docs: " + e.message, true));
  }

  function hideDocCanvas() {
    $("#doc-canvas").removeClass("visible");
  }

  function hideStoryCanvas() {
    $("#story-canvas").removeClass("visible");
  }

  function ensureDocPreviewMessage(msg) {
    $("#doc-preview").empty().text(msg || "Select a document to preview its contents here.");
  }

  function handlePanelVisibility(panelId) {
    const project = getCurrentProject();
    if (panelId === "setup-docs-panel") {
      if (project) {
        showDocCanvas(project, $("#doc-category-select").val());
      }
      hideStoryCanvas();
      hideCharacterCanvas();
    } else if (panelId === "character-panel") {
      hideDocCanvas();
      hideStoryCanvas();
      const name = project ? currentCharacterName || getActiveCharacterName(project) : null;
      if (project && name) {
        openCharacterCanvas(name, ensureCharacterRecord(project, name));
      }
    } else {
      hideDocCanvas();
      hideCharacterCanvas();
      hideStoryCanvas();
    }
  }

  function collapseAllMenuPanels() {
    suppressMenuToggle = true;
    $(".menu-panel").each(function () {
      this.open = false;
      $(this).removeClass("active");
    });
    suppressMenuToggle = false;
    hideDocCanvas();
    hideCharacterCanvas();
    hideStoryCanvas();
  }

  function activateMenuPanel(panelId) {
    suppressMenuToggle = true;
    $(".menu-panel").each(function () {
      if (this.id !== panelId) {
        this.open = false;
        $(this).removeClass("active");
      }
    });
    const target = document.getElementById(panelId);
    if (target) {
      target.open = true;
      $(target).addClass("active");
      handlePanelVisibility(panelId);
    }
    suppressMenuToggle = false;
  }

  async function bootstrapAfterGoogleAuth() {
    const authed = await ensureGoogleAuthorized();
    if (!authed) return;
    try {
      await syncProjectsFromDrive();
      await promptForDriveProjectSelection();
    } catch (e) {
      logLine("Failed to initialize Drive workspace: " + e.message, true);
      setAuthStatus("Drive setup failed: " + e.message);
    }
  }

  async function fetchCategoryDocuments(project, category, options = {}) {
    const draftsOnly = options.draftsOnly || false;
    const parentId = await ensureCategoryFolder(project, category);
    const files = await listDriveFiles(parentId);
    const docs = [];

    const pushDoc = (file, prefix = null, characterName = null, parentFolderId = null, isDraft = false) => {
      const display = prefix ? `${prefix}/${file.name}` : file.name;
      docs.push({
        id: file.id,
        filename: display,
        baseName: file.name,
        mimeType: file.mimeType,
        modifiedAt: file.modifiedTime ? new Date(file.modifiedTime) : null,
        mappedFileId: project.driveMappings?.[category]?.[file.id] || null,
        characterName,
        parentFolderId,
        isDraft,
      });
    };

    for (const file of files) {
      if (file.mimeType === "application/vnd.google-apps.folder" && category === CHARACTER_CATEGORY) {
        const nested = await listDriveFiles(file.id);
        if (draftsOnly) {
          const draftsFolder = nested.find((f) => f.mimeType === "application/vnd.google-apps.folder" && f.name === "drafts");
          if (!draftsFolder) continue;
          const draftFiles = await listDriveFiles(draftsFolder.id);
          draftFiles
            .filter((f) => f.mimeType !== "application/vnd.google-apps.folder")
            .forEach((child) => pushDoc(child, `${file.name}/drafts`, file.name, draftsFolder.id, true));
          continue;
        }
        nested
          .filter((f) => f.mimeType !== "application/vnd.google-apps.folder")
          .forEach((child) => pushDoc(child, file.name, file.name, file.id));
        continue;
      }
      if (file.mimeType === "application/vnd.google-apps.folder") continue;
      pushDoc(file, null, null, parentId, false);
    }

    return docs;
  }

  async function renderDocExplorer(project, category) {
    const $list = $("#doc-list");
    $list.empty();
    const draftsMode = docExplorerShowDrafts && category === CHARACTER_CATEGORY;
    const docs = await fetchCategoryDocuments(project, category, { draftsOnly: draftsMode });
    $("#doc-drafts-toggle")
      .text(draftsMode ? "Show Approved" : "Show Drafts")
      .prop("disabled", category !== CHARACTER_CATEGORY)
      .toggle(category === CHARACTER_CATEGORY);
    await warmImageCacheForDocs(docs);

    const $header = $("<div>").addClass("doc-row doc-row-header");
    $header.append($("<div>").text("Name"));
    $header.append($("<div>").text("Type"));
    $header.append($("<div>").text("Updated"));
    $header.append($("<div>").text("Actions"));
    $list.append($header);

    if (!docs.length) {
      $list.append(
        $("<div>")
          .addClass("doc-row")
          .append($("<div>").css("grid-column", "1 / -1").text("No documents found for this category yet."))
      );
      ensureDocPreviewMessage("Select a category or add new documents to preview them here.");
      return;
    }

    docs.forEach((doc) => {
      const $row = $("<div>").addClass("doc-row");
      $row.append($("<div>").text(doc.filename));
      $row.append($("<div>").text(doc.mimeType || "unknown"));
      const dateText = doc.modifiedAt ? doc.modifiedAt.toLocaleString() : "Unknown";
      $row.append($("<div>").text(dateText));
      const $actions = $("<div>").addClass("doc-actions");
      const $view = $("<button>").addClass("icon-button").attr("title", "Stream / view").text("👁️");
      $view.on("click", async () => {
        ensureDocPreviewMessage("Loading preview...");
        try {
          await viewDriveDocument(project, doc);
        } catch (e) {
          logLine("Error previewing document: " + e.message, true);
        }
      });
      $actions.append($view);

      if (doc.isDraft && category === CHARACTER_CATEGORY) {
        const $promote = $("<button>").text("⬆️ Promote");
        const $deleteDraft = $("<button>").text("🗑️ Delete");
        $promote.on("click", async () => {
          try {
            const characterName = doc.characterName || deriveProfileName(doc.baseName) || deriveCharacterNameFromFilename(doc.baseName);
            if (!characterName) {
              alert("Unable to infer character for this draft. Rename the file with the character name first.");
              return;
            }
            const content = await downloadDriveFile(doc.id);
            const draftEntry = {
              driveId: doc.id,
              filename: doc.baseName,
              type: /profile/i.test(doc.baseName) ? "profile-draft" : "gallery-draft",
              dataUrl: content.type === "image" ? content.data : null,
            };
            await promoteDraftPhoto(project, characterName, draftEntry);
            logLine(`Promoted draft ${doc.baseName} for ${characterName} from explorer.`);
            await renderDocExplorer(project, category);
          } catch (e) {
            logLine("Error promoting draft: " + e.message, true);
          }
        });
        $deleteDraft.on("click", async () => {
          const confirmDelete = confirm(`Delete draft ${doc.filename}? This only affects the drafts folder.`);
          if (!confirmDelete) return;
          try {
            await deleteDriveFile(doc.id);
            if (doc.characterName) {
              const rec = ensureCharacterRecord(project, doc.characterName);
              rec.draftPhotos = (rec.draftPhotos || []).filter((p) => p.driveId !== doc.id);
            }
            await renderDocExplorer(project, category);
            logLine(`Deleted draft ${doc.filename}.`);
          } catch (e) {
            logLine("Error deleting draft: " + e.message, true);
          }
        });
        $actions.append($promote, $deleteDraft);
      } else {
        const $delete = $("<button>").text("🗑️ Delete");
        $delete.on("click", async () => {
          const confirmDelete = confirm(`Delete ${doc.filename} from ${category}? This removes it from Google Drive and the vector store.`);
          if (!confirmDelete) return;
          try {
            const mapped = project.driveMappings?.[category]?.[doc.id];
            if (mapped) {
              const vsId = project.vectorStores && project.vectorStores[category];
              if (vsId) await deleteVectorStoreFile(vsId, mapped);
              await deleteOpenAIFile(mapped);
            }
            await deleteDriveFile(doc.id);
            forgetDriveMapping(project, category, doc.id);
            logLine(`Deleted ${doc.filename} from Drive.`);
            await renderDocExplorer(project, category);
          } catch (e) {
            logLine("Error deleting document: " + e.message, true);
          }
        });
        $actions.append($delete);
      }

      $row.append($actions);
      $list.append($row);
    });
  }

  function showImageModal(dataUrl, caption) {
    const $modal = $("#image-viewer");
    $("#image-viewer-img").attr("src", dataUrl || "");
    $("#image-viewer-caption").text(caption || "");
    $modal.addClass("visible");
  }

  function hideImageModal() {
    $("#image-viewer").removeClass("visible");
    $("#image-viewer-img").attr("src", "");
    $("#image-viewer-caption").text("");
  }

  async function viewDriveDocument(project, doc) {
    const content = await downloadDriveFile(doc.id);
    await previewDocument(project, doc, content);
    if (content.type === "image") {
      showImageModal(content.data, doc.filename);
      return;
    }

    const blob = content.blob || new Blob([content.data || ""], { type: content.contentType || "application/octet-stream" });
    const url = URL.createObjectURL(blob);
    window.open(url, "_blank");
    setTimeout(() => URL.revokeObjectURL(url), 60_000);
  }

  async function previewDocument(project, doc, existingContent = null) {
    const content = existingContent || (await downloadDriveFile(doc.id));
    const $preview = $("#doc-preview");
    $preview.empty();
    if (content.type === "text") {
      $preview.text(content.data || "(no text)");
      return;
    }
    if (content.type === "image") {
      $preview.append($("<img>").attr("src", content.data));
      return;
    }

    const blob = content.blob;
    if (blob) {
      const url = URL.createObjectURL(blob);
      const $link = $("<a>").addClass("download-link").attr("href", url).attr("download", doc.filename).text("Download file");
      $preview.append($("<div>").text("Preview unavailable. Download instead:"));
      $preview.append($link);
    } else {
      $preview.text("Preview unavailable for this file type.");
    }
  }

  // ==============================
  // UI WIRING
  // ==============================

  $(function () {
    loadProjectsFromStorage();
    loadModelPreference();
    refreshProjectListUI();
    refreshCharacterSelectUI({ characters: {} });
    refreshStoryTargetSelectors({ chapters: {}, outlines: {} }, true);
    setConsoleExpanded(false);
    $("#api-key-input").val(apiKey);
    $("#api-key-status").text("Preloaded test key (change as needed)");
    logLine("API key preloaded for testing. Replace or clear as needed.");
    logLine("Novel Studio HTML client loaded. Sign in with Google Drive to begin.");
    setStatus("Connect Google Drive to begin.");
    ensureDocPreviewMessage();
    setAppLocked(true);
    setCharacterMode(characterConversationMode);
    collapseAllMenuPanels();

    const $googleBtn = $("#google-auth-btn");
    const $googleReloadBtn = $("#google-reload-btn");

    async function kickOffGoogleSdk(forceReload = false) {
      try {
        ensureDriveConfigPresent();
        setAuthStatus(forceReload ? "Reloading Google SDK assets..." : "Loading Google SDK assets...");
        $googleBtn.prop("disabled", true).text("Loading Google SDK...");
        if (forceReload) {
          resetGoogleSdkState();
          logLine("Forcing Google SDK reload after user request.");
        }
        await prepareGoogleSdk();
        $googleBtn.prop("disabled", false).text("Sign in with Google Drive");
        setAuthStatus("Google SDK ready. Sign in to continue.");
      } catch (e) {
        const reason = e?.message || "Google SDK failed to initialize.";
        logLine(reason, true);
        setAuthStatus("Google sign-in unavailable: " + reason);
        $googleBtn.prop("disabled", false).text("Retry Google SDK load");
      }
    }

    kickOffGoogleSdk();

    $googleReloadBtn.on("click", async function () {
      const previous = $(this).text();
      $(this).prop("disabled", true).text("Reloading SDK...");
      await kickOffGoogleSdk(true);
      $(this).prop("disabled", false).text(previous);
    });

    $googleBtn.on("click", async function () {
      const $btn = $(this);
      const previousLabel = $btn.text();
      if (!googleDriveReady) {
        setAuthStatus("Google SDK is still loading. Retrying initialization...");
        try {
          await prepareGoogleSdk();
        } catch (e) {
          const reason = e?.message || "Google SDK failed to initialize.";
          logLine("Google SDK initialization failed: " + reason, true);
          setAuthStatus("Google sign-in unavailable: " + reason);
          return;
        }
        if (!googleDriveReady) {
          setAuthStatus("Google SDK is still loading. Please try again in a moment.");
          return;
        }
      }
      $btn.prop("disabled", true).text("Signing in...");
      try {
        await bootstrapAfterGoogleAuth();
      } catch (e) {
        logLine("Google sign-in failed: " + e.message, true);
        setAuthStatus("Google sign-in failed: " + e.message);
      } finally {
        $btn.prop("disabled", false).text(previousLabel);
      }
    });

    $("#picker-refresh-btn").on("click", function () {
      refreshProjectPicker(projectPickerSelection || currentProjectName || null);
    });

    $("#picker-use-selected-btn").on("click", function () {
      if (!projectPickerSelection) {
        alert("Select a Drive project first.");
        return;
      }
      hideProjectPicker(projectPickerSelection);
    });

    $("#picker-cancel-btn").on("click", function () {
      hideProjectPicker(null);
    });

    $("#picker-create-project-btn").on("click", async function () {
      const created = await createProject($("#picker-new-project-input").val());
      if (created) {
        $("#picker-new-project-input").val("");
        hideProjectPicker(created);
      }
    });

    $("#image-viewer-close").on("click", hideImageModal);
    $("#image-viewer").on("click", function (e) {
      if (e.target === this) hideImageModal();
    });

    $("#character-mode-toggle button").on("click", function () {
      const mode = $(this).data("mode");
      setCharacterMode(mode);
    });

    $("#story-mode-toggle button").on("click", function () {
      const mode = $(this).data("mode");
      setStoryCanvasMode(mode);
    });

    $("#model-select").on("change", function () {
      const model = $(this).val();
      setAssistantModel(model);
    });

    $("#console-panel-header").on("click", function () {
      setConsoleExpanded(!consoleExpanded);
    });

    $("#console-toggle-btn").on("click", function (e) {
      e.stopPropagation();
      setConsoleExpanded(!consoleExpanded);
    });

    $("#doc-category-select").on("change", function () {
      const project = getCurrentProject();
      if (!project) return;
      showDocCanvas(project, $(this).val());
    });

    $("#doc-add-btn").on("click", function () {
      $("#doc-canvas-upload").click();
    });

    $("#doc-refresh-btn").on("click", function () {
      const project = getCurrentProject();
      if (!project) return;
      showDocCanvas(project, $("#doc-category-select").val());
    });

    $("#open-story-canvas-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) {
        alert("Select a project first.");
        return;
      }
      await openStoryCanvas(project, false);
    });

    $("#story-send-btn").on("click", async function () {
      const project = getCurrentProject();
      await sendStoryCanvasPrompt(project);
    });

    $("#story-user-prompt").on("keydown", function (e) {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        $("#story-send-btn").click();
      }
    });

    $("#story-save-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      const text = getStoryCanvasText();
      await saveStoryArcText(project, text);
      pushStoryMessage("system", "Story arc saved to Drive.");
    });

    $("#story-refresh-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      await refreshStoryArcFromDrive(project);
    });

    $("#doc-drafts-toggle").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      const category = $("#doc-category-select").val();
      if (category !== CHARACTER_CATEGORY) return;
      docExplorerShowDrafts = !docExplorerShowDrafts;
      await renderDocExplorer(project, category);
    });

    $("#doc-resync-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      const category = $("#doc-category-select").val();
      try {
        await resyncCategoryFromDrive(project, category);
      } catch (e) {
        logLine("Failed to resync category: " + e.message, true);
      }
    });

    $("#doc-canvas-upload").on("change", async function (e) {
      const project = getCurrentProject();
      if (!project) return;
      const files = e.target.files || [];
      const category = $("#doc-category-select").val();
      if (!files.length) return;
      try {
        await uploadDocumentsToCategory(project, category, files);
        await renderDocExplorer(project, category);
        ensureDocPreviewMessage();
      } catch (err) {
        logLine("Error uploading documents: " + err.message, true);
      } finally {
        $(this).val("");
      }
    });

    $(".menu-panel").on("toggle", function () {
      if (suppressMenuToggle) return;
      if (this.open) {
        activateMenuPanel(this.id);
      } else {
        $(this).removeClass("active");
        if (this.id === "character-panel") {
          hideCharacterCanvas();
          resetCharacterCanvasSession();
        }
        if (this.id === "setup-docs-panel") {
          hideDocCanvas();
        }
      }
    });

    $("#canvas-gallery-prev").on("click", function () {
      const track = document.getElementById("canvas-gallery-track");
      if (track) track.scrollBy({ left: -140, behavior: "smooth" });
    });

    $("#canvas-gallery-next").on("click", function () {
      const track = document.getElementById("canvas-gallery-track");
      if (track) track.scrollBy({ left: 140, behavior: "smooth" });
    });

    $("#set-api-key-btn").on("click", function () {
      const key = $("#api-key-input").val().trim();
      if (!key) {
        apiKey = null;
        $("#api-key-status").text("Not set");
        logLine("API key cleared.");
      } else {
        apiKey = key;
        $("#api-key-status").text("Set (stored only in memory)");
        logLine("API key set in memory.");
      }
    });

    $("#create-project-btn").on("click", async function () {
      const created = await createProject($("#new-project-name").val());
      if (created) {
        $("#new-project-name").val("");
        await selectProject(created);
      }
    });

    $("#exit-drive-project-btn").on("click", function () {
      exitDriveProject();
    });

    $("#open-project-picker-btn").on("click", async function () {
      const authed = await ensureGoogleAuthorized();
      if (!authed) return;
      await promptForDriveProjectSelection();
    });

    $("#delete-project-btn").on("click", function () {
      if (!currentProjectName || !projects[currentProjectName]) {
        alert("No project currently selected.");
        return;
      }
      if (!confirm("Delete project '" + currentProjectName + "' from localStorage? This does NOT delete Google Drive or OpenAI resources.")) {
        return;
      }
      delete projects[currentProjectName];
      saveProjectsToStorage();
      currentProjectName = null;
      $("#current-project-name").text("None");
      refreshProjectListUI();
      refreshCharacterSelectUI({ characters: {} });
      logLine("Deleted project (local only).");
    });

    $("#refresh-characters-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      try {
        await refreshCharacterRoster(project);
      } catch (e) {
        logLine("Error refreshing character roster: " + e.message, true);
      }
    });

    $("#scan-characters-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      try {
        await scanForOtherCharacters(project);
      } catch (e) {
        logLine("Error scanning for characters: " + e.message, true);
      }
    });

    $("#work-character-sheet-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      try {
        await workOnCharacterSheet(project);
      } catch (e) {
        logLine("Error updating character sheet: " + e.message, true);
      }
    });

    $("#character-photo-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      try {
        await reviewOrEditCharacterPhotos(project);
      } catch (e) {
        logLine("Error updating character photos: " + e.message, true);
      }
    });

    $("#init-assistants-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      try {
        await initAssistantsForProject(project);
      } catch (e) {
        logLine("Error initializing assistants: " + e.message, true);
      }
    });

    $("#upload-docs-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      try {
        await uploadDocsForCategory(project);
      } catch (e) {
        logLine("Error uploading docs: " + e.message, true);
      }
    });

    $("#refresh-category-files-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      try {
        await loadCategoryFileOptions(project, $("#doc-category-select").val());
      } catch (e) {
        logLine("Error refreshing file list: " + e.message, true);
      }
    });

    $("#list-category-files-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      try {
        await listFilesInCategory(project);
      } catch (e) {
        logLine("Error listing files: " + e.message, true);
      }
    });

    $("#remove-category-file-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      try {
        await removeFileFromCategory(project);
      } catch (e) {
        logLine("Error removing file: " + e.message, true);
      }
    });

    $("#canvas-send-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      await sendCharacterCanvasPrompt(project);
    });

    $("#save-character-sheet-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      try {
        await saveCanvasCharacterSheet(project);
      } catch (e) {
        logLine("Error saving character sheet: " + e.message, true);
      }
    });

    $("#download-character-docx-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      const name = currentCharacterName;
      if (!name) {
        alert("Select a character first.");
        return;
      }
      const text = getCanvasText();
      await downloadCharacterSheetDocx(name, text);
    });

    $("#upload-character-docx-btn").on("click", function () {
      $("#canvas-upload-input").click();
    });

    $("#canvas-upload-input").on("change", async function (e) {
      const project = getCurrentProject();
      if (!project) return;
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      try {
        await replaceCharacterSheetFromUpload(project, file);
      } catch (err) {
        logLine("Error applying uploaded docx: " + err.message, true);
      } finally {
        $("#canvas-upload-input").val("");
      }
    });

    $("#build-trilogy-outline-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      try {
        await buildTrilogyOutline(project);
      } catch (e) {
        logLine("Error building trilogy outline: " + e.message, true);
      }
    });

    $("#build-book-outline-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      try {
        await buildBookOutline(project);
      } catch (e) {
        logLine("Error building book outline: " + e.message, true);
      }
    });

    $("#refresh-story-targets-btn").on("click", function () {
      const project = getCurrentProject();
      if (!project) return;
      refreshStoryTargetSelectors(project, true);
    });

    $("#book-select").on("change", function () {
      const project = getCurrentProject();
      if (!project) return;
      populateActsForSelectedBook(project);
    });

    $("#act-select").on("change", function () {
      const project = getCurrentProject();
      if (!project) return;
      populateChaptersForSelectedAct(project);
    });

    $("#draft-chapter-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      try {
        await draftChapter(project);
      } catch (e) {
        logLine("Error drafting chapter: " + e.message, true);
      }
    });

    $("#draft-whole-book1-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      const { bookNumber } = getSelectedBookActChapter(project);
      if (!bookNumber) {
        alert("Select a book in Story Targets first.");
        return;
      }
      if (
        !confirm(
          `Draft entire Book ${bookNumber} from its JSON outline? This may use many tokens and time to complete.`
        )
      ) {
        return;
      }
      try {
        await draftWholeBook(project, bookNumber);
      } catch (e) {
        logLine(`Error drafting whole Book ${bookNumber}: ` + e.message, true);
      }
    });

    $("#edit-chapter-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      try {
        await editChapter(project);
      } catch (e) {
        logLine("Error editing chapter: " + e.message, true);
      }
    });

    $("#review-book-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      try {
        await reviewWholeBook(project);
      } catch (e) {
        logLine("Error in book-level review: " + e.message, true);
      }
    });

    $("#tts-chapter-btn").on("click", async function () {
      const project = getCurrentProject();
      if (!project) return;
      try {
        await ttsForChapter(project);
      } catch (e) {
        logLine("Error generating TTS: " + e.message, true);
      }
    });

    $("#sora-stub-btn").on("click", async function () {
      await soraStub();
    });
  });
</script>
</body>
</html>
